"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[60],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var r=a.createContext({}),u=function(e){var t=a.useContext(r),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(r.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,o=e.originalType,r=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=u(n),h=s,d=m["".concat(r,".").concat(h)]||m[h]||p[h]||o;return n?a.createElement(d,i(i({ref:t},c),{},{components:n})):a.createElement(d,i({ref:t},c))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var r in t)hasOwnProperty.call(t,r)&&(l[r]=t[r]);l.originalType=e,l.mdxType="string"==typeof e?e:s,i[1]=l;for(var u=2;u<o;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},8952:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>l,toc:()=>u});var a=n(7462),s=(n(7294),n(3905));const o={title:"13 reasons why Dart is worse than Kotlin"},i=void 0,l={permalink:"/blog/2020/07/20/dart-vs-kotlin",source:"@site/blog/2020-07-20-dart-vs-kotlin.md",title:"13 reasons why Dart is worse than Kotlin",description:"As you probably know from my previous articles and talks, I love Flutter. I really think that this is one of the best options to develop a high-quality multi-platform app. It\u2019s so easy to create custom views with complex animations \u2013 especially, comparing with the native Android View layer. The way it promotes composition over inheritance and immutable widgets, or encourages you to make the view a pure function of a state makes me happy.",date:"2020-07-20T00:00:00.000Z",formattedDate:"July 20, 2020",tags:[],readingTime:9.115,hasTruncateMarker:!0,authors:[],frontMatter:{title:"13 reasons why Dart is worse than Kotlin"},prevItem:{title:"1 year in production with Flutter: lessons learned",permalink:"/blog/2021/02/05/one-year-flutter"},nextItem:{title:"UI tests in Flutter with Azure Pipelines",permalink:"/blog/2020/06/15/ci-azure"}},r={authorsImageUrls:[]},u=[{value:"#1 No null safety",id:"1-no-null-safety",level:2},{value:"#2 No data classes",id:"2-no-data-classes",level:2},{value:"#3 No sealed classes",id:"3-no-sealed-classes",level:2},{value:"#4 No custom values in enums",id:"4-no-custom-values-in-enums",level:2},{value:"#5 Compiler is not smart enough",id:"5-compiler-is-not-smart-enough",level:2},{value:"#6 No singletons",id:"6-no-singletons",level:2},{value:"#7 No switch/if/try expressions",id:"7-no-switchiftry-expressions",level:2},{value:"#8 No protected keyword",id:"8-no-protected-keyword",level:2},{value:"#9 No type aliases",id:"9-no-type-aliases",level:2},{value:"#10 No concise syntax",id:"10-no-concise-syntax",level:2},{value:"#11 No nested classes/extensions",id:"11-no-nested-classesextensions",level:2},{value:"#12 No proper generic variance",id:"12-no-proper-generic-variance",level:2},{value:"#13 No final classes",id:"13-no-final-classes",level:2}],c={toc:u};function p(e){let{components:t,...n}=e;return(0,s.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("p",null,"As you probably know from my previous articles and talks, I love Flutter. I really think that this is one of the best options to develop a high-quality multi-platform app. It\u2019s so easy to create custom views with complex animations \u2013 especially, comparing with the native Android View layer. The way it promotes composition over inheritance and immutable widgets, or encourages you to make the view a pure function of a state makes me happy."),(0,s.kt)("p",null,"Unfortunately, I cannot say the same about Dart, the language that Flutter is written in, and that you\u2019re supposed to use to develop Flutter apps. Why? There are at least 13 reasons for that."),(0,s.kt)("h2",{id:"1-no-null-safety"},"#1 No null safety"),(0,s.kt)("p",null,"Yes, I know that this will hopefully become obsolete in the (near?) future, but for now, we have to deal with it. Anyway, for the language with the first release in the year 2018 (I mean Dart 2 of course), it\u2019s a shame not to have null safety from the very beginning."),(0,s.kt)("h2",{id:"2-no-data-classes"},"#2 No data classes"),(0,s.kt)("p",null,"Data classes are classes whose main purpose is to hold data ","[sic!]",". They are highly useful as Value Object from DDD, and also, with proper language support, it\u2019s very convenient to use immutable data classes for functional programming style."),(0,s.kt)("p",null,"By proper support I mean something like this in Kotlin:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'data class User(val name: String, val age: Int)\n\nval user1 = User(name = "John", age = 30)\nval user2 = user1.copy(age = 20)\n')),(0,s.kt)("p",null,"Even without implementing copy (and equality) functionality the Dart way is more verbose:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-dart"},"class User {\n  User({this.name, this.age});\n\n  final String name;\n  final int age;\n}\n\nfinal user1 = User(name: 'John', age: 30);\nfinal user2 = User(name: user1.name, age: 20);\n")),(0,s.kt)("p",null,"And it still lacks some features that are provided by Kotlin. E.g. in Kotlin you can pass these parameters as positional or as named (and even mix them: ",(0,s.kt)("inlineCode",{parentName:"p"},"val user = User('John', age = 30))"),", while in Dart you\u2019re ",(0,s.kt)("em",{parentName:"p"},"either")," making them positional ",(0,s.kt)("em",{parentName:"p"},"or")," named \u2013 but in that case they will be optional and default to ",(0,s.kt)("inlineCode",{parentName:"p"},"null"),"."),(0,s.kt)("p",null,"There is a nice package ",(0,s.kt)("inlineCode",{parentName:"p"},"built_value")," that solves the problem with deep equality check and generating copy method, and we use it a lot in our codebase, but it\u2019s not an ideal solution."),(0,s.kt)("p",null,"First, it still requires some boilerplate code compared to Kotlin version:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-dart"},"abstract class User implements Built<User, UserBuilder> {\n  User._();\n\n  factory User([void Function(UserBuilder) updates]) = _$User;\n\n  String get name;\n\n  int get age;\n}\n\nfinal user1 = User((b) => b\n  ..name = 'John'\n  ..age = 30);\n\nfinal user2 = user1.rebuild((b) => b..age = 20);\n")),(0,s.kt)("p",null,"Second, it lacks some features, e.g. you cannot easily enforce required parameters during compile time."),(0,s.kt)("p",null,"Will we have proper support for data classes in Dart? ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/dart-lang/language/issues/314"},"Probably"),", but not anytime soon."),(0,s.kt)("h2",{id:"3-no-sealed-classes"},"#3 No sealed classes"),(0,s.kt)("p",null,'Another feature in Kotlin language that we use a lot: sealed classes, aka co-product types, aka sum types, aka "enums on steroids"\u2026 They are extremely useful if you want to make your types sound.'),(0,s.kt)("p",null,"Essentially, they represent a restricted class hierarchy: a value can have one of the types from a limited set. Unlike enum, this value is not a singleton, but a proper class that can have multiple instances with different states."),(0,s.kt)("p",null,"Why is it useful? Let\u2019s see at probably the most common example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'sealed class Result<out VALUE> {\n    data class Error(val error: Throwable) : Result<Nothing>()\n    data class Success<VALUE>(val value: VALUE) : Result<VALUE>()\n}\n\nfun process(result: Result<String>): String = when (result) {\n    is Result.Error -> "Error: ${result.error}"\n    is Result.Success -> "Success: ${result.value}"\n}\n')),(0,s.kt)("p",null,"This is a nice alternative to exceptions: instead of catching exceptions (or sometimes ",(0,s.kt)("em",{parentName:"p"},"forgetting")," to do that) you\u2019re forced to deal with the result, which can be ",(0,s.kt)("em",{parentName:"p"},"either")," error ",(0,s.kt)("em",{parentName:"p"},"or")," valid result (the corresponding type in many functional languages and libraries is called exactly like this: Either). Not only you will have to take a possible error into account, but Kotlin will provide some nice features as well. Do you see casting inside when branches? You don\u2019t, because no manual casting is needed. Kotlin is smart enough to do ",(0,s.kt)("em",{parentName:"p"},"smart casting")," (pun intended) automatically."),(0,s.kt)("p",null,"What about Dart? Well, maybe ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/dart-lang/language/issues/349"},"someday")," we will get there."),(0,s.kt)("h2",{id:"4-no-custom-values-in-enums"},"#4 No custom values in enums"),(0,s.kt)("p",null,"Sometimes (well, actually quite often) you need to associate some value with enum. In Kotlin it\u2019s as easy as this:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},"\nenum class Level(val value: Int) {\n    INFO(10),\n    WARNING(20),\n    ERROR(30)\n}\n\nval value = Level.WARNING.value\n")),(0,s.kt)("p",null,"Dart? ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/dart-lang/sdk/issues/33698"},"Looks like no"),". You can use extensions to achieve similar behavior:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-dart"},"enum Level { info, warning, level }\n\nextension LevelValue on Level {\n  int get value {\n    switch(this) {\n      case Level.info:\n        return 10;\n      case Level.warning:\n        return 20;\n      case Level.level:\n        return 30;\n    }\n  }\n}\n\nfinal value = Level.warning.value;\n")),(0,s.kt)("p",null,"But first, it\u2019s more verbose, and second, that leads us to the next point\u2026"),(0,s.kt)("h2",{id:"5-compiler-is-not-smart-enough"},"#5 Compiler is not smart enough"),(0,s.kt)("p",null,"The previous example gives me this warning:"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"This function has a return type of \u2018int\u2019, but doesn\u2019t end with a return statement. Try adding a return statement, or changing the return type to \u2018void\u2019.")),(0,s.kt)("p",null,"What? ",(0,s.kt)("inlineCode",{parentName:"p"},"Level")," enum has only 3 possible options, and they are all listed. There\u2019s no way for this function to return void. I don\u2019t want to add default branch here (otherwise, if I add another option to the enum, I can forget to update the extension, and it will silently return an incorrect result). I don\u2019t want to suppress the warning for the same reason. I want an error here, if and only if I didn\u2019t match all the possible options: that\u2019s what Kotlin does."),(0,s.kt)("h2",{id:"6-no-singletons"},"#6 No singletons"),(0,s.kt)("p",null,"How can you define singleton in Kotlin? Like this: ",(0,s.kt)("inlineCode",{parentName:"p"},"object Singleton"),". Anything similar in Dart? I guess this is the simplest way:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-dart"},"class Singleton {\n  const Singleton._();\n\n  factory Singleton() => const Singleton._();\n}\n")),(0,s.kt)("p",null,'Not a big deal, of course, but when you have to write this for every case it adds up. And we use them a lot in our Kotlin project e.g. as "constant" branches of sealed classes\u2026 Oh wait, we don\u2019t have sealed classes in Dart anyway.'),(0,s.kt)("h2",{id:"7-no-switchiftry-expressions"},"#7 No switch/if/try expressions"),(0,s.kt)("p",null,"Do you remember the example from #3 No sealed classes? There\u2019s no return keyword, yet the function is returning a string. That\u2019s possible thanks to two things:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},'fun getAnswer(): String = "42"')," is equivalent to ",(0,s.kt)("inlineCode",{parentName:"li"},'fun getAnswer(): String { return "42" }'),". In Dart you can do it as well with ",(0,s.kt)("inlineCode",{parentName:"li"},"String getAnswer() => '42';"),"."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"when")," is an expression: it means you can return the result of ",(0,s.kt)("inlineCode",{parentName:"li"},"when")," and the compiler is smart enough to infer the correct type since every branch is returning ",(0,s.kt)("inlineCode",{parentName:"li"},"String"),".\nAnd it\u2019s not only about concise syntax. With returning when compiler forces us to provide all the possible options (e.g. in case of enums or sealed class you must either specify all the options or use ",(0,s.kt)("inlineCode",{parentName:"li"},"else")," branch).")),(0,s.kt)("h2",{id:"8-no-protected-keyword"},"#8 No protected keyword"),(0,s.kt)("p",null,"In order to make method (or variable) private, you need to prefix its name with underscore. For making it protected you can use @protected annotation from the meta package. In the first case, you\u2019ll get a compilation error when trying to access it from outside of the allowed scope. In the second case, the best you can get is static analyzer feedback. Dart doesn\u2019t have language support for protected members so it\u2019s all or nothing. No compromises."),(0,s.kt)("h2",{id:"9-no-type-aliases"},"#9 No type aliases"),(0,s.kt)("p",null,"Actually, type aliases in Dart exist, but only for function types. So you can write something like ",(0,s.kt)("inlineCode",{parentName:"p"},"typedef FormatDate = String Function(DateTime);"),", but not ",(0,s.kt)("inlineCode",{parentName:"p"},"typedef Json = Map<String, dynamic>"),". So, if you\u2019re working with json in your project, add this type to snippets, you will use it ",(0,s.kt)("em",{parentName:"p"},"often"),"."),(0,s.kt)("p",null,"Yeah, the sun ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/dart-lang/language/issues/65"},"will shine")," on our side of the fence. Someday\u2026"),(0,s.kt)("h2",{id:"10-no-concise-syntax"},"#10 No concise syntax"),(0,s.kt)("p",null,'Ok, you can say here: "You just got used to Kotlin syntax, and try to turn Dart into Kotlin". Well, that\u2019s true, I find Kotlin syntax pretty nice, but it isn\u2019t just about getting used to it. Things like lambda syntax are so much more concise in Kotlin, e.g. ',(0,s.kt)("inlineCode",{parentName:"p"},"listOf(1, 2, 3).map { it.toString() }")," looks better than ",(0,s.kt)("inlineCode",{parentName:"p"},"[1,2,3].map((i) => i.toString());")," even in such a simple example. When you have a multiline lambda (or chains of lambdas) Dart way becomes too complex for writing and reading. And this required semicolon\u2026 Come on, it\u2019s the year 2020!"),(0,s.kt)("h2",{id:"11-no-nested-classesextensions"},"#11 No nested classes/extensions"),(0,s.kt)("p",null,"What about having some way to nest classes? E.g. we would like to do something like this with messages:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-dart"},"abstract class Translations {\n  static abstract class Common {\n    static String yes = 'Yes';\n    static String no = 'No';\n  }\n\n  static abstract class Auth {\n    static String logIn = 'Log in';\n    static String logOut = 'Log out';\n  }\n}\n\nfinal message = Translations.Auth.logIn;\n")),(0,s.kt)("p",null,"Dart? Sure, we have a ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/dart-lang/language/issues/336"},"feature request")," for that."),(0,s.kt)("h2",{id:"12-no-proper-generic-variance"},"#12 No proper generic variance"),(0,s.kt)("p",null,"In Dart type variables in generic classes are covariant. Why is it bad? Because it\u2019s an easy way to shoot yourself in the foot. Let\u2019s take a look at this example:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-dart"},"class Animal {}\n\nclass Dog extends Animal {}\n\nclass Cat extends Animal {}\n\nvoid main() {\n  List<Animal> animals = [Dog()];\n  List<Cat> cats = [];\n  cats.add(animals.first);\n}\n")),(0,s.kt)("p",null,"This will compile without any problems, but in the runtime, you will receive an error:"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"TypeError: Instance of 'Dog': type 'Dog' is not a subtype of type 'Cat'.")),(0,s.kt)("p",null,"You can try to do the same trick in Kotlin:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},"abstract class Animal\nclass Dog : Animal()\nclass Cat : Animal()\n\nfun main() {\n    val animals = listOf<Animal>(Dog())\n    val cats = mutableListOf<Cat>()\n    cats.add(animals.first())\n}\n")),(0,s.kt)("p",null,"But it won\u2019t even compile. It will give you an error:"),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Type inference failed. Expected type mismatch: inferred type is Animal but Cat was expected.")),(0,s.kt)("p",null,(0,s.kt)("a",{parentName:"p",href:"https://kotlinlang.org/docs/reference/generics.html#variance"},"Here")," you can read about generics variance in Kotlin, and ",(0,s.kt)("a",{parentName:"p",href:"https://github.com/dart-lang/language/issues/753"},"this")," is an ongoing discussion about variance in Dart."),(0,s.kt)("h2",{id:"13-no-final-classes"},"#13 No final classes"),(0,s.kt)("p",null,'Effective Java says: "Design and document for inheritance or else prohibit it". So in Java it\u2019s a good practice to use final classes as often as possible. Kotlin takes one step further and makes classes final by default. What about Dart? Well, there\u2019s no way at all to make a class final. You cannot prohibit inheritance. Freedom for everyone!'),(0,s.kt)("hr",null),(0,s.kt)("p",null,"So, are there only negative things I can say about Dart? Well, there are actually some points that I really like:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Classes are interfaces. Each class implicitly defines an interface that consists of its public members. So you can just implement any class and provide overridden functionality: nice thing to use in tests for mocking implementation."),(0,s.kt)("li",{parentName:"ul"},"No type erasure. Unlike Kotlin, ",(0,s.kt)("inlineCode",{parentName:"li"},"List<String>")," is still ",(0,s.kt)("inlineCode",{parentName:"li"},"List<String>")," in runtime."),(0,s.kt)("li",{parentName:"ul"},"Last but definitely not least: language is evolving. We\u2019ve got extensions, probably we will get null safety soon enough. Hopefully, other things from my list will become obsolete someday and Dart will eventually become ",(0,s.kt)("del",{parentName:"li"},"Kotlin")," a modern and safe language.")))}p.isMDXComponent=!0}}]);