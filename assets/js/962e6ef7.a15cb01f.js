"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1149],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},d=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=r(e,["components","mdxType","originalType","parentName"]),d=c(n),u=a,m=d["".concat(l,".").concat(u)]||d[u]||h[u]||o;return n?i.createElement(m,s(s({ref:t},p),{},{components:n})):i.createElement(m,s({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=d;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:a,s[1]=r;for(var c=2;c<o;c++)s[c]=n[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}d.displayName="MDXCreateElement"},994:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>r,toc:()=>c});var i=n(7462),a=(n(7294),n(3905));const o={},s="App Architecture: Faster, Better\u2026 Simpler",r={permalink:"/blog/2024/10/15/app-architecture",source:"@site/blog/2024-10-15-app-architecture/index.md",title:"App Architecture: Faster, Better\u2026 Simpler",description:"As a Staff Mobile Engineer at Mews, I\u2019ve come to realize the title \u201cStaff Engineer\u201d is quite vague, with responsibilities varying from company to company and even between departments. In my role, I don\u2019t belong to any specific team; instead, I assist other engineers and teams with code reviews, architectural decisions, and ad-hoc issues. I also consult for other companies and startups, reviewing their code and mentoring their teams. This exposure to different approaches in app architecture has given me insights into what works and what doesn\u2019t. Today, I\u2019d like to discuss how to make your architecture simpler, more reliable, and more manageable.",date:"2024-10-15T00:00:00.000Z",formattedDate:"October 15, 2024",tags:[],readingTime:14.67,hasTruncateMarker:!0,authors:[],frontMatter:{},nextItem:{title:"DCM: When the Built-In Analyzer Isn't Enough",permalink:"/blog/2023/11/21/dcm"}},l={authorsImageUrls:[]},c=[{value:"What is (and isn\u2019t) app architecture",id:"what-is-and-isnt-app-architecture",level:2},{value:"The goal of software architecture",id:"the-goal-of-software-architecture",level:2},{value:"Defining app architecture",id:"defining-app-architecture",level:2},{value:"Understanding components in your app",id:"understanding-components-in-your-app",level:2},{value:"An example component structure",id:"an-example-component-structure",level:2},{value:"Widgets are not just dumb views",id:"widgets-are-not-just-dumb-views",level:2},{value:"Do we need all these layers?",id:"do-we-need-all-these-layers",level:2},{value:"About dependency inversion",id:"about-dependency-inversion",level:2},{value:"Where does BLoC belong?",id:"where-does-bloc-belong",level:2},{value:"Re-examining SOLID principles",id:"re-examining-solid-principles",level:2},{value:"Single Responsibility Principle (SRP)",id:"single-responsibility-principle-srp",level:3},{value:"Open/Closed Principle (OCP)",id:"openclosed-principle-ocp",level:3},{value:"Liskov Substitution Principle (LSP)",id:"liskov-substitution-principle-lsp",level:3},{value:"Interface Segregation Principle (ISP)",id:"interface-segregation-principle-isp",level:3},{value:"Dependency Inversion Principle (DIP)",id:"dependency-inversion-principle-dip",level:3},{value:"General thoughts on SOLID",id:"general-thoughts-on-solid",level:3},{value:"The misunderstood DRY principle",id:"the-misunderstood-dry-principle",level:2},{value:"Focusing on component relations",id:"focusing-on-component-relations",level:2},{value:"Understanding through component graphs",id:"understanding-through-component-graphs",level:2},{value:"Assessing component dependencies",id:"assessing-component-dependencies",level:2},{value:"Avoiding cycles in dependencies",id:"avoiding-cycles-in-dependencies",level:2},{value:"Ensuring loose coupling and high cohesion",id:"ensuring-loose-coupling-and-high-cohesion",level:2},{value:"Tools for analyzing component relations",id:"tools-for-analyzing-component-relations",level:2},{value:"Using Lakos for dependency graphs",id:"using-lakos-for-dependency-graphs",level:3},{value:"Dart code metrics for component analysis",id:"dart-code-metrics-for-component-analysis",level:3},{value:"Benefits of this approach",id:"benefits-of-this-approach",level:2},{value:"Flexibility",id:"flexibility",level:3},{value:"Transparency",id:"transparency",level:3},{value:"Maintainability",id:"maintainability",level:3},{value:"Simplicity",id:"simplicity",level:3},{value:"Scalability",id:"scalability",level:3},{value:"Is this Clean Architecture?",id:"is-this-clean-architecture",level:2},{value:"Key differences",id:"key-differences",level:2},{value:"Conclusion",id:"conclusion",level:2}],p={toc:c};function h(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"As a Staff Mobile Engineer at Mews, I\u2019ve come to realize the title \u201cStaff Engineer\u201d is quite vague, with responsibilities varying from company to company and even between departments. In my role, I don\u2019t belong to any specific team; instead, I assist other engineers and teams with code reviews, architectural decisions, and ad-hoc issues. I also consult for other companies and startups, reviewing their code and mentoring their teams. This exposure to different approaches in app architecture has given me insights into what works and what doesn\u2019t. Today, I\u2019d like to discuss how to make your architecture simpler, more reliable, and more manageable."),(0,a.kt)("p",null,"This is the text version of my ",(0,a.kt)("a",{parentName:"p",href:"https://fluttercon.dev/"},"talk at Fluttercon Berlin 2024"),". You can find the video ",(0,a.kt)("a",{parentName:"p",href:"https://www.droidcon.com/2024/09/03/app-architecture-faster-better-simpler/"},"here"),"."),(0,a.kt)("h2",{id:"what-is-and-isnt-app-architecture"},"What is (and isn\u2019t) app architecture"),(0,a.kt)("p",null,"Before we define what app architecture is, let\u2019s clarify what it\u2019s not. When I\u2019m introduced to a new app and ask the team to describe their current architecture, I often hear responses like:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"\u201cIt\u2019s BLoC.\u201d"),(0,a.kt)("li",{parentName:"ul"},"\u201cWe use Riverpod.\u201d"),(0,a.kt)("li",{parentName:"ul"},"\u201cIt\u2019s an MVVM architecture.\u201d")),(0,a.kt)("p",null,"The issue is that these are not descriptions of an app\u2019s architecture. BLoC and Riverpod are state management tools, and MVVM is an architectural pattern for the presentation layer. While important, they don\u2019t define your app\u2019s overall architecture."),(0,a.kt)("p",null,"Sometimes, the response is, \u201cWe have a SOLID-based architecture.\u201d Again, this doesn\u2019t tell me much. SOLID is a set of principles that can be useful (though not always, as we\u2019ll discuss later), but it\u2019s not a representation of your app\u2019s architecture."),(0,a.kt)("p",null,"Another popular answer is, \u201cWe use Clean Architecture.\u201d You might think this is spot-on\u2014it even has \u201carchitecture\u201d in the name. However, there are several problems with this:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Lack of specificity:")," Even if applied correctly, Clean Architecture doesn\u2019t say much about your specific app. It\u2019s a set of principles to build your app\u2019s architecture, resulting in countless possible architectures."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Misapplication:")," I often see implementations of Clean Architecture that don\u2019t follow its core principles."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Unsuitability for Flutter apps:")," The strict approach to Clean Architecture doesn\u2019t work well with Flutter apps. I discussed this in detail in my article ",(0,a.kt)("a",{parentName:"li",href:"https://ookamikb.dev/blog/2023/02/14/clean-architecture-vs-pragmatic-architecture/"},"Clean Architecture vs. Pragmatic Architecture"),". In short, Clean Architecture speaks to entire software systems where a mobile app is just a part. It focuses too much on separate deployments and is overly defensive about business logic\u2014which most mobile apps lack.")),(0,a.kt)("h2",{id:"the-goal-of-software-architecture"},"The goal of software architecture"),(0,a.kt)("p",null,"Before defining app architecture, let\u2019s discuss its goal. I appreciate Robert Martin\u2019s definition from his book Clean Architecture:"),(0,a.kt)("p",null,"\u201cThe goal of software architecture is to minimize the human resources required to build and maintain the required system.\u201d"),(0,a.kt)("p",null,"The key word here is ",(0,a.kt)("strong",{parentName:"p"},"\u201cmaintain\u201c"),". We seldom create apps that aren\u2019t intended for future maintenance. Maintenance\u2014which includes fixing bugs and adding new features\u2014is the most significant part of an app\u2019s lifecycle. Therefore, making this phase as straightforward as possible is crucial."),(0,a.kt)("h2",{id:"defining-app-architecture"},"Defining app architecture"),(0,a.kt)("p",null,"So, what is app architecture? According to Wikipedia:"),(0,a.kt)("blockquote",null,(0,a.kt)("p",{parentName:"blockquote"},"\u201cSoftware architecture is the set of structures needed to reason about a software system and the discipline of creating such structures and systems. Each structure comprises software elements, relations among them, and properties of both elements and relations.\u201d")),(0,a.kt)("p",null,"Many tutorials focus on components and their properties but often overlook the crucial aspect of relationships between components."),(0,a.kt)("h2",{id:"understanding-components-in-your-app"},"Understanding components in your app"),(0,a.kt)("p",null,"Let\u2019s delve into components, which I\u2019ll use interchangeably with features and modules. Simon Brown defines a component as:"),(0,a.kt)("p",null,"\u201cA grouping of related functionality behind a nice clean interface, which resides inside an execution environment like an application.\u201d"),(0,a.kt)("p",null,"In the context of app components:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"They are not screens, although a screen can be part of a component."),(0,a.kt)("li",{parentName:"ul"},"They are not necessarily user flows. While something like a \u201cUser Registration Flow\u201d can be a component, components shouldn\u2019t be divided exclusively by user flows."),(0,a.kt)("li",{parentName:"ul"},"They are not just global responsibilities. For example, \u201cauth\u201d doesn\u2019t have to be a separate component encompassing all authentication-related elements.")),(0,a.kt)("p",null,"Instead, think of components from the loose coupling, high cohesion perspective:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"High cohesion:")," Everything inside the module should have closely related functionality."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Loose coupling:")," Connections to the outside should be minimal."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Encapsulation:")," Other components shouldn\u2019t concern themselves with a module\u2019s implementation details; they should treat it as a black box.")),(0,a.kt)("h2",{id:"an-example-component-structure"},"An example component structure"),(0,a.kt)("p",null,"What can be inside a component? As long as you adhere to encapsulation and loose coupling/high cohesion, the specifics are flexible. Here\u2019s a structure I often use:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img.png",src:n(1426).Z,width:"1600",height:"744"})),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Screens:")," The top-level layer and the first candidate to be used by other components. If you can use a whole screen from another module, that\u2019s excellent\u2014you don\u2019t need to care about its implementation."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Widgets:")," Screens consist of widgets. Contrary to some practices, widgets aren\u2019t just dumb view components (more on this shortly)."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Services layer:")," Some call this the Business Logic layer, but I prefer not to, as most apps lack true business logic. Instead, this layer handles application logic\u2014abstracted from the UI but specific to the app. State management patterns like BLoC typically belong here."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Data layer:")," This includes implementations of repositories and API clients. Keep them as simple as possible; you usually mock these in tests, so you don\u2019t want complex logic here."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"Models layer:")," Only models shared between different parts of the module or between different modules go here (though I usually discourage cross-module sharing). If a model is only used by a repository or service, place it close to the corresponding class in the same file. These aren\u2019t rich domain models; they\u2019re typically just data holders.")),(0,a.kt)("h2",{id:"widgets-are-not-just-dumb-views"},"Widgets are not just dumb views"),(0,a.kt)("p",null,"Some developers split widgets into ModelViews and Views, but I advise against this. I find MVVM in Flutter to be an anti-pattern, as I discussed in ",(0,a.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=J7fDHul6Oao"},"this video"),"."),(0,a.kt)("h2",{id:"do-we-need-all-these-layers"},"Do we need all these layers?"),(0,a.kt)("p",null,"Definitely not. Avoid adding abstractions if they don\u2019t encapsulate any logic. If your service merely proxies calls to the repository, you don\u2019t need it. Let the widget directly call the repository. Layers can communicate with any lower layers, not just their immediate child layer. In practice, you\u2019ll often have just a couple of layers: widgets and services or widgets and data. However, dependency direction should always be one-way."),(0,a.kt)("p",null,"You can set up the DCM static analyzer to enforce this direction, preventing, for example, importing a file from the data folder into a file in the widgets folder."),(0,a.kt)("h2",{id:"about-dependency-inversion"},"About dependency inversion"),(0,a.kt)("p",null,"You might notice that there\u2019s no dependency inversion in this structure\u2014the services layer calls the data layer directly. This might seem terrible, but let\u2019s discuss why we need this principle: it allows us to depend on interfaces, not implementations. In Dart, every class defines an implicit interface. With implicit interfaces, you can have another implementation of the class for testing without needing additional abstractions that can complicate thinking."),(0,a.kt)("p",null,"This doesn\u2019t mean you should never create separate interfaces. They can be useful, especially when combined with the Interface Segregation Principle. However, avoid creating a separate class with only one implementation in the main code, particularly when that implementation is just the interface name with an Impl suffix."),(0,a.kt)("h2",{id:"where-does-bloc-belong"},"Where does BLoC belong?"),(0,a.kt)("p",null,"Does BLoC always belong to the services layer? It depends. BLoC, as a library, is an implementation of the Finite State Machine pattern. If you use it to handle application logic and state, it sits in the services folder. If it\u2019s managing a complex UI state, it\u2019s part of the widgets layer. Asking whether BLoC is UI or services is like asking whether a Singleton is part of the data layer or if a Factory should only be used in views."),(0,a.kt)("h2",{id:"re-examining-solid-principles"},"Re-examining SOLID principles"),(0,a.kt)("p",null,"Since we\u2019ve touched on the Dependency Inversion Principle, let\u2019s discuss the other SOLID principles."),(0,a.kt)("h3",{id:"single-responsibility-principle-srp"},"Single Responsibility Principle (SRP)"),(0,a.kt)("p",null,"This is perhaps the most misinterpreted principle, partly due to its confusing name. Many believe it\u2019s about a class or function doing only one thing. In Clean Architecture, Robert Martin clarifies that SRP is about one reason to change, meaning responsibility to one actor. It\u2019s more about grouping related functionality together, aligning with the loose coupling and high cohesion principle. In this sense, it\u2019s invaluable for structuring your app\u2019s modules."),(0,a.kt)("h3",{id:"openclosed-principle-ocp"},"Open/Closed Principle (OCP)"),(0,a.kt)("p",null,"This principle states that software entities should be open for extension but closed for modification. On a module level, it suggests having a stable and extensible API. However, not all components need to be stable\u2014some change frequently due to product requirements or dependencies."),(0,a.kt)("h3",{id:"liskov-substitution-principle-lsp"},"Liskov Substitution Principle (LSP)"),(0,a.kt)("p",null,"LSP is crucial when dealing with class hierarchies, but inheritance can be complex and fragile. In general, it\u2019s often better to avoid deep inheritance structures."),(0,a.kt)("h3",{id:"interface-segregation-principle-isp"},"Interface Segregation Principle (ISP)"),(0,a.kt)("p",null,"This is the one principle where I have few reservations. It\u2019s beneficial because if your code doesn\u2019t depend on methods it doesn\u2019t use, the system becomes easier to understand, test, and maintain. However, it can lead to more boilerplate code. For example, any class with more than one client and more than one method (like a Repository or ApiClient) might violate this principle. Again, be reasonable in its application."),(0,a.kt)("h3",{id:"dependency-inversion-principle-dip"},"Dependency Inversion Principle (DIP)"),(0,a.kt)("p",null,"As previously discussed, I advise against applying DIP rigidly within component layers. It can be highly useful when dealing with the stability and flexibility of components, but it shouldn\u2019t be applied everywhere just because it\u2019s possible."),(0,a.kt)("h3",{id:"general-thoughts-on-solid"},"General thoughts on SOLID"),(0,a.kt)("p",null,"SOLID principles are somewhat vague initially. Authors, including Robert Martin, present them as universal, promoting their use at class, module, and architecture levels. While they often make sense, they can sometimes feel artificial. I suggest being skeptical\u2014know the principles but avoid following them blindly. They are not laws. You can build bad software that follows these principles and good software that violates them (in some places, not everywhere)."),(0,a.kt)("p",null,"Violating any of these principles isn\u2019t inherently good or bad\u2014it\u2019s about why you violate them or apply them. If you can justify your decisions, adherence to the principles becomes less critical."),(0,a.kt)("h2",{id:"the-misunderstood-dry-principle"},"The misunderstood DRY principle"),(0,a.kt)("p",null,"I chose to discuss SOLID and DRY because they frequently appear in job postings, almost becoming an id\xe9e fixe."),(0,a.kt)("p",null,"The DRY (Don\u2019t Repeat Yourself) principle, along with SRP, is one of the most misinterpreted. The confusion often arises from its name. It\u2019s not about code repetition per se; it\u2019s about maintaining a single source of truth for your logic."),(0,a.kt)("p",null,"People often describe WET (Write Everything Twice) as the opposite of DRY, which highlights the misunderstanding. The number of repetitions isn\u2019t the issue; it\u2019s the repetition of logic or knowledge that should be avoided. If you\u2019re repeatedly creating a widget with the same parameters, you don\u2019t necessarily need to introduce a new wrapping widget."),(0,a.kt)("h2",{id:"focusing-on-component-relations"},"Focusing on component relations"),(0,a.kt)("p",null,"Now that we\u2019ve discussed components and their internal relationships, let\u2019s switch to a more intriguing and less discussed topic: relations between components."),(0,a.kt)("p",null,"When I ask about your app architecture, this is usually what I want to hear\u2014how your components interact. This is the main characteristic that determines whether your app is a \u201cbig ball of mud\u201d or a well-structured, maintainable piece of software. It also allows someone to understand what your app does without delving into the code."),(0,a.kt)("h2",{id:"understanding-through-component-graphs"},"Understanding through component graphs"),(0,a.kt)("p",null,"Consider these two images:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img_1.png",src:n(7051).Z,width:"1600",height:"625"})),(0,a.kt)("p",null,"The left one describes a general architecture or principles that can be used to create an app architecture\u2014it doesn\u2019t tell me anything specific about your app. The right one depicts the architecture of a specific app. It\u2019s much more informative when we want to understand what your app is about and how it\u2019s built."),(0,a.kt)("p",null,"By examining the components graph, we can deduce that the app involves movies, favorites, search, and profiles\u2014it appears to be a movie search app that allows users to create a list of favorite movies."),(0,a.kt)("h2",{id:"assessing-component-dependencies"},"Assessing component dependencies"),(0,a.kt)("p",null,"Looking at the \u201ccontent\u201d module, we see it doesn\u2019t depend on any other component:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img_2.png",src:n(752).Z,width:"1600",height:"747"})),(0,a.kt)("p",null,"This means ease of testing: Since it doesn\u2019t depend on anything else, we can test it in isolation, regardless of the state of the rest of the app."),(0,a.kt)("p",null,"At the same time, many other components depend on it, so changes here can cascade through the app:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img_3.png",src:n(8300).Z,width:"1600",height:"625"})),(0,a.kt)("p",null,"This makes it a \u201cstable\u201d component\u2014you don\u2019t want its API to change frequently."),(0,a.kt)("p",null,"Conversely, the \u201cdashboard\u201d component has no other components depending on it:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img_4.png",src:n(1481).Z,width:"1600",height:"535"})),(0,a.kt)("p",null,"Such a component is considered \u201cirresponsible.\u201d It\u2019s safe to change because you won\u2019t break other components, making it very unstable."),(0,a.kt)("p",null,"However, since it depends on every other component (directly or transitively), testing it could be challenging without proper abstractions:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img_5.png",src:n(895).Z,width:"1600",height:"663"})),(0,a.kt)("p",null,"Most likely, this component serves as an entry point to the rest of the app, making it a good candidate for end-to-end or integration tests."),(0,a.kt)("p",null,"Without even looking at the code, we\u2019ve gained insights into:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The app\u2019s functionality."),(0,a.kt)("li",{parentName:"ul"},"Which parts are easier to test."),(0,a.kt)("li",{parentName:"ul"},"Which components might be hard to change.")),(0,a.kt)("h2",{id:"avoiding-cycles-in-dependencies"},"Avoiding cycles in dependencies"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img_6.png",src:n(6979).Z,width:"1600",height:"535"})),(0,a.kt)("p",null,"One crucial aspect to monitor is the absence of cycles in your dependencies\u2014your dependencies should form a Directed Acyclic Graph (DAG). Cycles turn modules within the cycle into one big module. For example, if the \u201cprofile\u201d module depends on \u201cauth,\u201d \u201cauth\u201d depends on \u201cdashboard,\u201d and \u201cdashboard\u201d depends back on \u201cprofile,\u201d you effectively have one large module. You can\u2019t use or test these modules separately, and changes in one will likely necessitate changes in the others."),(0,a.kt)("h2",{id:"ensuring-loose-coupling-and-high-cohesion"},"Ensuring loose coupling and high cohesion"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img_7.png",src:n(6175).Z,width:"1600",height:"663"})),(0,a.kt)("p",null,"Check for loose coupling and high cohesion within your modules. If you notice few internal connections but many external ones, you might be violating this principle. To fix this, consider rearranging files within modules. Remember, modules aren\u2019t necessarily grouped by use case or screens\u2014they\u2019re about keeping highly cohesive functionality together."),(0,a.kt)("h2",{id:"tools-for-analyzing-component-relations"},"Tools for analyzing component relations"),(0,a.kt)("h3",{id:"using-lakos-for-dependency-graphs"},"Using Lakos for dependency graphs"),(0,a.kt)("p",null,"For a total graph of all file relationships, I use the Lakos library. Even for a small project, the graph can look intimidating:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img_8.png",src:n(3179).Z,width:"1600",height:"625"})),(0,a.kt)("p",null,"The good news is you don\u2019t need to check it manually; Lakos can report if there are cycles in the graph."),(0,a.kt)("p",null,"In most cases, you\u2019re only interested in the outcome: isAcyclic: true. You can set up Lakos to return an error if cycles are detected, integrating it into your CI/CD pipeline. It works quickly because it doesn\u2019t perform static analysis of Dart code \u2014it simply parses import statements."),(0,a.kt)("h3",{id:"dart-code-metrics-for-component-analysis"},"Dart code metrics for component analysis"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img_9.png",src:n(4632).Z,width:"1600",height:"625"})),(0,a.kt)("p",null,"For more complex tasks like grouping files into modules, the Dart Code Metrics tool with its new analyze-structure command is helpful. Note that this command is in an early preview, so some functionality might be missing or subject to change."),(0,a.kt)("p",null,"This tool allows you to build a components graph, grouping dependencies within components:"),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"img_10.png",src:n(4014).Z,width:"1600",height:"747"})),(0,a.kt)("p",null,"While it doesn\u2019t automatically check for cycles yet, the components graph is simpler, making manual checks feasible."),(0,a.kt)("p",null,"You can also run a script on the Graphviz file it produces to detect cycles."),(0,a.kt)("p",null,"Remember, it\u2019s important to check for cycles in both the full graph and the components graph, as one might be acyclic while the other isn\u2019t."),(0,a.kt)("h2",{id:"benefits-of-this-approach"},"Benefits of this approach"),(0,a.kt)("h3",{id:"flexibility"},"Flexibility"),(0,a.kt)("p",null,"With more or less independent modules, it\u2019s easier to split work among developers and make independent changes."),(0,a.kt)("h3",{id:"transparency"},"Transparency"),(0,a.kt)("p",null,"Having an overview of stable and unstable components allows you to plan refactorings and understand which components are easier to test and which are risky to change."),(0,a.kt)("h3",{id:"maintainability"},"Maintainability"),(0,a.kt)("p",null,"As the second law of thermodynamics suggests, entropy (or chaos) in any isolated system tends to increase over time. Without constant maintenance, disorder grows. However, with this approach, chaos can be localized\u2014no matter how messy one module gets, it shouldn\u2019t significantly affect others."),(0,a.kt)("h3",{id:"simplicity"},"Simplicity"),(0,a.kt)("p",null,"Avoid unnecessary abstractions. Don\u2019t focus on multiple layers just for the sake of it. Keep things simple and concentrate on the relationships between your modules. A litmus test to check if an abstraction is needed: ask yourself why you added it. If your answer starts with \u201cIf in the future\u2026,\u201d stop\u2014you probably don\u2019t need it. Saying \u201cit\u2019s cleaner\u201d isn\u2019t a sufficient reason."),(0,a.kt)("h3",{id:"scalability"},"Scalability"),(0,a.kt)("p",null,"With a decomposed system, you can strategically target weak points and evolve the system. If your system grows further, you can easily switch to a modular architecture\u2014groups of components can be extracted as separate modules."),(0,a.kt)("h2",{id:"is-this-clean-architecture"},"Is this Clean Architecture?"),(0,a.kt)("p",null,"When rehearsing my presentation, someone commented that this approach resembles Clean Architecture. So, is it an alternative or just a rebranded idea?"),(0,a.kt)("p",null,"Well, both yes and no. Throughout this discussion, I\u2019ve referred to \u201cClean Architecture\u201d as it\u2019s commonly implemented in tutorials and real-life projects, where developers take sample implementations from original articles and directly apply them to Flutter apps. I advocate for implementing the ideas of Clean Architecture\u2014clear boundaries, well-defined dependencies, and module isolation\u2014while remaining skeptical and pragmatic. In that sense, this approach is closer to the original intent of Clean Architecture than blindly replicating UseCase, Presenter, Repository, and Datasource classes across projects."),(0,a.kt)("h2",{id:"key-differences"},"Key differences"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Simplification:")," Streamlining the architecture to focus on what\u2019s essential."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Inversion of dependency inversion:")," Sometimes, just having direct dependencies is more practical."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Component structuring:")," Organizing by components defined through cohesion."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Small components:")," Keeping components as small and manageable as possible."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Focus on relationships:")," Concentrating on how components interact rather than adhering strictly to predefined layers.")),(0,a.kt)("h2",{id:"conclusion"},"Conclusion"),(0,a.kt)("p",null,"Simplifying your app architecture doesn\u2019t mean sacrificing robustness or scalability. By focusing on component relationships, embracing pragmatism over dogmatism, and utilizing tools to monitor dependencies, you can create an architecture that\u2019s both manageable and adaptable."),(0,a.kt)("p",null,"If you have any questions or thoughts, feel free to reach out. Let\u2019s continue the conversation on building better, more maintainable apps."))}h.isMDXComponent=!0},1426:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img-c4824d7c03be58c57b4ce6a5aebb559f.png"},7051:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_1-223ccc95c3c80316f363c06947164e4d.png"},4014:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_10-434eebec70fcf5ef290091e9aa0e8244.png"},752:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_2-70059397726c13681853254e65786946.png"},8300:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_3-223ccc95c3c80316f363c06947164e4d.png"},1481:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_4-1b5d9b87dcb2738c8d6de6c33b3e0a33.png"},895:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_5-cb88cb063d5b3999d858ce8ea24c225e.png"},6979:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_6-1b5d9b87dcb2738c8d6de6c33b3e0a33.png"},6175:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_7-cb88cb063d5b3999d858ce8ea24c225e.png"},3179:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_8-223ccc95c3c80316f363c06947164e4d.png"},4632:(e,t,n)=>{n.d(t,{Z:()=>i});const i=n.p+"assets/images/img_9-223ccc95c3c80316f363c06947164e4d.png"}}]);