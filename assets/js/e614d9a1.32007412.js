"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2710],{4769:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>d,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>l,toc:()=>s});var n=t(7462),o=(t(7294),t(3905));t(1839);const i={title:"Rounded image view in Android"},r=void 0,l={permalink:"/blog/2018/03/02/rounded-images",source:"@site/blog/2018-03-02-rounded-images.md",title:"Rounded image view in Android",description:"The common use-case is like this: you need to get an image from some server, resize and cache it (you\u2019re using Picasso for this, aren\u2019t you?), make corners rounded (ok, this is not the most popular use-case, but it\u2019s what this article is about) and load it into view. So, how can we make rounded corners?",date:"2018-03-02T00:00:00.000Z",formattedDate:"March 2, 2018",tags:[],readingTime:2.525,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Rounded image view in Android"},prevItem:{title:"Developing a Kiosk Application",permalink:"/blog/2018/07/19/developing-kiosk"},nextItem:{title:"Email-\u0440\u0430\u0441\u0441\u044b\u043b\u043a\u0430 \u0441\u043e \u0441\u0432\u043e\u0435\u0433\u043e \u0441\u0435\u0440\u0432\u0435\u0440\u0430: \u043f\u043e\u0434\u0432\u043e\u0434\u043d\u044b\u0435 \u043a\u0430\u043c\u043d\u0438",permalink:"/blog/2016/01/17/email"}},d={authorsImageUrls:[]},s=[{value:"Option #1. Overlay",id:"option-1-overlay",level:2},{value:"Option #2. clipPath",id:"option-2-clippath",level:2},{value:"Option #3. BitmapShader",id:"option-3-bitmapshader",level:2},{value:"Option #4. RoundedBitmapDrawable",id:"option-4-roundedbitmapdrawable",level:2}],p={toc:s};function u(e){let{components:a,...t}=e;return(0,o.kt)("wrapper",(0,n.Z)({},p,t,{components:a,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"The common use-case is like this: you need to get an image from some server, resize and cache it (you\u2019re using Picasso for this, aren\u2019t you?), make corners rounded (ok, this is not ",(0,o.kt)("em",{parentName:"p"},"the most")," popular use-case, but it\u2019s what this article is about) and load it into view. So, how can we make rounded corners?"),(0,o.kt)("p",null,"As usual, we have several ways to achieve this in Android."),(0,o.kt)("h2",{id:"option-1-overlay"},"Option #1. Overlay"),(0,o.kt)("p",null,"Some desperate person can offer you to place your image view inside ",(0,o.kt)("inlineCode",{parentName:"p"},"FrameLayout"),", add another image above it with a transparent body and solid corners and\u2026 you\u2019re done. Do I need to tell you that this is very bad practice, and you should never do that?"),(0,o.kt)("h2",{id:"option-2-clippath"},"Option #2. clipPath"),(0,o.kt)("p",null,"Rather a simple method. You just need to create a custom view with an overridden ",(0,o.kt)("inlineCode",{parentName:"p"},"onDraw")," method of ",(0,o.kt)("inlineCode",{parentName:"p"},"ImageView")," and use method ",(0,o.kt)("inlineCode",{parentName:"p"},"clipPath")," on canvas instance there. The problem is that path clipping doesn\u2019t support anti-aliasing, so your image will have ugly sharp edges."),(0,o.kt)("h2",{id:"option-3-bitmapshader"},"Option #3. BitmapShader"),(0,o.kt)("p",null,"A way better option is to use a ",(0,o.kt)("inlineCode",{parentName:"p"},"Paint")," with ",(0,o.kt)("inlineCode",{parentName:"p"},"BitmapShader"),". It allows filling the rounded rectangle with a texture, not only with a simple color. Luckily we have ",(0,o.kt)("inlineCode",{parentName:"p"},"RoundedBitmapDrawable")," within support library that uses this technique, we just need to combine image loading with Picasso and transforming it into one view, which leads us to option #4:"),(0,o.kt)("h2",{id:"option-4-roundedbitmapdrawable"},"Option #4. RoundedBitmapDrawable"),(0,o.kt)("p",null,"So, let\u2019s start. The code is written in Kotlin, because\u2026 well, why would you write in Java when you have Kotlin?"),(0,o.kt)("p",null,"As we will use our view with Picasso only, we don\u2019t even need to inherit it from ",(0,o.kt)("inlineCode",{parentName:"p"},"ImageView"),", simple ",(0,o.kt)("inlineCode",{parentName:"p"},"View")," would be enough:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class RoundedImageView(\n  context: Context,\n  attributeSet: AttributeSet?\n) : View(context, attributeSet), Target {\n    constructor(context: Context) : this(context, null)\n}\n")),(0,o.kt)("p",null,"In order to allow Picasso to load an image into our view, it should implement ",(0,o.kt)("inlineCode",{parentName:"p"},"Target")," interface, which includes 3 methods: ",(0,o.kt)("inlineCode",{parentName:"p"},"onPrepareLoad"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"onBitmapFailed")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"onBitmapLoaded"),". All the magic is done in ",(0,o.kt)("inlineCode",{parentName:"p"},"onBitmapLoaded")," method:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"override fun onBitmapLoaded(bitmap: Bitmap?, from: Picasso.LoadedFrom?) {\n    val roundedDrawable = RoundedBitmapDrawableFactory.create(resources, bitmap)\n    roundedDrawable.cornerRadius = dip(DEFAULT_RADIUS).toFloat()\n    drawable = roundedDrawable\n}\n")),(0,o.kt)("p",null,"Finally, we need to draw our ",(0,o.kt)("inlineCode",{parentName:"p"},"Drawable")," in ",(0,o.kt)("inlineCode",{parentName:"p"},"onDraw")," method (sounds ",(0,o.kt)("em",{parentName:"p"},"very")," reasonable, isn\u2019t it?):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"override fun onDraw(canvas: Canvas?) {\n    drawable?.setBounds(0, 0, width, height)\n    drawable?.draw(canvas)\n}\n")),(0,o.kt)("p",null,"So the complete code together with helper method for loading image by URL string is here:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-kotlin"},"class RoundedImageView(context: Context, attributeSet: AttributeSet?) : View(context, attributeSet), Target {\n    constructor(context: Context) : this(context, null)\n\n    private var drawable: Drawable? = null\n        set(value) {\n            field = value\n            postInvalidate()\n        }\n\n    fun loadImage(url: String?) {\n        if (url == null) {\n            drawable = null\n        } else {\n            Picasso.with(context)\n                    .load(url)\n                    .placeholder(R.drawable.image_stub)\n                    .error(R.drawable.image_stub)\n                    .into(this)\n        }\n    }\n\n    override fun onDraw(canvas: Canvas?) {\n        drawable?.setBounds(0, 0, width, height)\n        drawable?.draw(canvas)\n    }\n\n    override fun onPrepareLoad(placeHolderDrawable: Drawable?) {\n        drawable = placeHolderDrawable\n    }\n\n    override fun onBitmapFailed(errorDrawable: Drawable?) {\n        drawable = errorDrawable\n    }\n\n    override fun onBitmapLoaded(bitmap: Bitmap?, from: Picasso.LoadedFrom?) {\n        val roundedDrawable = RoundedBitmapDrawableFactory.create(resources, bitmap)\n        roundedDrawable.cornerRadius = dip(DEFAULT_RADIUS).toFloat()\n        drawable = roundedDrawable\n    }\n\n    companion object {\n        private const val DEFAULT_RADIUS = 4\n    }\n}\n")))}u.isMDXComponent=!0}}]);