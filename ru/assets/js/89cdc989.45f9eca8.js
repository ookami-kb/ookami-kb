"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[3372],{3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>p});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var d=n.createContext({}),l=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},c=function(e){var t=l(e.components);return n.createElement(d.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,d=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),u=l(a),p=r,h=u["".concat(d,".").concat(p)]||u[p]||m[p]||o;return a?n.createElement(h,i(i({ref:t},c),{},{components:a})):n.createElement(h,i({ref:t},c))}));function p(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=u;var s={};for(var d in t)hasOwnProperty.call(t,d)&&(s[d]=t[d]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=a[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},9331:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>m,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var n=a(7462),r=(a(7294),a(3905));const o={title:"Working with NFC in Flutter",date:"2022-09-02"},i=void 0,s={permalink:"/ru/blog/2022/09/02/flutter-nfc",source:"@site/blog/2022-09-02-flutter-nfc/index.md",title:"Working with NFC in Flutter",description:"Enter our career fair project",date:"2022-09-02T00:00:00.000Z",formattedDate:"2 \u0441\u0435\u043d\u0442\u044f\u0431\u0440\u044f 2022 \u0433.",tags:[],readingTime:10.92,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Working with NFC in Flutter",date:"2022-09-02"},nextItem:{title:"ViewModel \u0432\u043e Flutter \u2013 \u044d\u0442\u043e \u0430\u043d\u0442\u0438\u043f\u0430\u0442\u0442\u0435\u0440\u043d",permalink:"/ru/blog/2021/12/19/viewmodel-ru"}},d={authorsImageUrls:[]},l=[{value:"Enter our career fair project",id:"enter-our-career-fair-project",level:2},{value:"What is a key cutter?",id:"what-is-a-key-cutter",level:3},{value:"How did we go about it?",id:"how-did-we-go-about-it",level:3},{value:"What is NFC?",id:"what-is-nfc",level:2},{value:"Different standards",id:"different-standards",level:2},{value:"iOS vs Android \u2013 UX, custom behavior",id:"ios-vs-android--ux-custom-behavior",level:2},{value:"Implementation",id:"implementation",level:2},{value:"Demo",id:"demo",level:2}],c={toc:l};function m(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,n.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(2794).Z,width:"1920",height:"1080"})),(0,r.kt)("h2",{id:"enter-our-career-fair-project"},"Enter our career fair project"),(0,r.kt)("p",null,"For the latest career fair at ",(0,r.kt)("a",{parentName:"p",href:"https://www.mff.cuni.cz/en"},"MatFyz"),', we wanted to build something interesting: from one side, it should be more than just "here is our merch, come work with us"; from another side, it should showcase the products we were working on at Mews.'),(0,r.kt)("p",null,'Since one of our products is a kiosk for self-service check-ins at hotels, we decided to emulate a hotel check-in experience with guests entering their details into a registration card, cutting their "key" with an emulated key cutter, and later taking part in a lottery with randomly selecting winning room numbers.'),(0,r.kt)("h3",{id:"what-is-a-key-cutter"},"What is a key cutter?"),(0,r.kt)("p",null,'If you google "key cutter" images, it will show you something like this:'),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(1582).Z,width:"580",height:"580"})),(0,r.kt)("p",null,"This is definitely not the device hotel guests are supposed to use to check into their rooms."),(0,r.kt)("p",null,'A hotel key cutter is basically an RFID-card encoder: an electronic device that looks like a payment terminal. During "traditional" check-in, a receptionist takes an empty RFID-card and uses this device to write some information on the card. Later, the room door lock reads this information and opens the door for you. This process of "cutting" the key card is usually not visible, often cards are prepared in advance before check-in.'),(0,r.kt)("p",null,"When using the self-service kiosk, you can do this on your own: following instructions on the screen, you take a new RFID-card from the pile and place it on the key cutter:"),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(3493).Z,width:"5120",height:"3200"})),(0,r.kt)("p",null,"There can be more complex devices (e.g., with automatic card dispensers), but we will emulate exactly this type, which is pretty popular."),(0,r.kt)("h3",{id:"how-did-we-go-about-it"},"How did we go about it?"),(0,r.kt)("p",null,'This article will be about this "key cutting" process. At first, we wanted to set up a real key cutter, but there are a lot of technical and legal problems associated with them, so we decided to create a simple mobile app that will write a room number on an NFC-card. Later, a user can just come up with this card so that we can read their room number and match it with the winning numbers.'),(0,r.kt)("p",null,"Let's talk about this overall process of key cutting and how it works in production for a real hotel kiosk:"),(0,r.kt)("mermaid",{value:"sequenceDiagram\n    Kiosk->>Server: Add CutKey command\n    Server->>Connector: CutKey command added\n    Connector->>Server: Command is accepted\n    Server->>Kiosk: Command is accepted\n    Connector->>Key Cutter: Cut key\n    Key Cutter->>Connector: Key is ready\n    Connector->>Server: Command is processed\n    Server->>Kiosk: Command is processed"}),(0,r.kt)("p",null,'In our setup, Kiosk doesn\'t communicate directly with Key Cutter. Instead, when the guest presses the "Cut key" button, Kiosk issues a command to our Web Server, and Server creates a command in the special queue. In the hotel, there is a separate desktop application (Connector) that listens to this queue and communicates with the hardware Key Cutter. When the key is cut, Key Cutter notifies Connector, and Connector sends the confirmation back to Server. After that, Server notifies Kiosk via Websocket that the key is ready.'),(0,r.kt)("p",null,"It sounds like a complex setup (and it is), but it allows us to completely decouple Kiosk from Key Cutters \u2013 and since Kiosk is not the only client that deals with Key Cutters (and other peripherals), we keep all the knowledge on how to work with peripherals in one place."),(0,r.kt)("p",null,'In our "emulated" version, both the Key Cutter and Connector roles are fulfilled by the mobile app. The good thing is that Kiosk already uses our public API, the same one that is used by the Connector desktop app. That means that we already have the API implementation in Dart and can reuse it for our "key cutter".'),(0,r.kt)("p",null,"So the emulated workflow looks like this:"),(0,r.kt)("mermaid",{value:"sequenceDiagram\n    Kiosk->>Server: Add CutKey command\n    Server->>App: CutKey command added\n    App->>Server: Command is accepted\n    Server->>Kiosk: Command is accepted\n    App->>App: Cut key\n    App->>Server: Command is processed\n    Server->>Kiosk: Command is processed"}),(0,r.kt)("p",null,'In fact, we\'re just merging two entities, Key Cutter and Connector, into one mobile app. Kiosk still communicates with Server, but all the logic of receiving the key cutting command and "cutting" the key now happens in the custom app.'),(0,r.kt)("p",null,"Now let\u2019s discuss this app in detail. For that, we will need to know more about NFC."),(0,r.kt)("h2",{id:"what-is-nfc"},"What is NFC?"),(0,r.kt)("p",null,'Let\'s start with another question: "What is RFID?"'),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("em",{parentName:"mdxAdmonitionTitle"},"Beginning NFC")," by Tom Igoe, Don Coleman, Brian Jepson"),(0,r.kt)("p",{parentName:"admonition"},"Imagine you\u2019re sitting on your porch at night. You turn on the porch light, and you can see your neighbor as he passes close to your house because the light reflects off him back to your eyes. That\u2019s passive RFID. ","[...]"),(0,r.kt)("p",{parentName:"admonition"},"Now imagine you turn on your porch light, and your neighbor in his home sees it and flicks on his porch light so that you can see him waving hello from his porch. That\u2019s active RFID. ","[...]"),(0,r.kt)("p",{parentName:"admonition"},"RFID is a lot like those two porches. You and your neighbor know each other\u2019s faces, but you don\u2019t really learn a lot about each other that way. You don\u2019t exchange any meaningful messages. RFID is not a communications technology; rather, it\u2019s designed for identification. RFID tags can hold a small amount of data, and you can read and write to them from RFID readers, but the amount of data we\u2019re talking about is trivial, a thousand bytes or less.")),(0,r.kt)("p",null,"RFID and NFC are often conflated, but they\u2019re not the same thing. Though NFC readers can read from and write to some RFID tags, NFC has more capabilities than RFID, and enables a greater range of uses. You can think of NFC as an extension of RFID, building on a few of the many RFID standards to create a wider data exchange platform."),(0,r.kt)("p",null,"So, what is NFC?"),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("a",{parentName:"mdxAdmonitionTitle",href:"https://nfc-forum.org/what-is-nfc/"},"https://nfc-forum.org/what-is-nfc/")),(0,r.kt)("p",{parentName:"admonition"},"Near Field Communication (NFC) is a contact-less communication technology based on a radio frequency (RF) field using a base frequency of 13.56 MHz. It is designed to exchange data between two devices through a simple touch gesture.")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"RFID"),(0,r.kt)("th",{parentName:"tr",align:null},"NFC"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Uses radio frequency"),(0,r.kt)("td",{parentName:"tr",align:null},"Uses radio frequency")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Identification technology"),(0,r.kt)("td",{parentName:"tr",align:null},"Communication technology")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"No single standard"),(0,r.kt)("td",{parentName:"tr",align:null},"Standardized")))),(0,r.kt)("h2",{id:"different-standards"},"Different standards"),(0,r.kt)("p",null,"We decided to go with the ",(0,r.kt)("a",{parentName:"p",href:"https://pub.dev/packages/nfc_manager"},"nfc_manager")," plugin. It's a wrapper around platform specific NFC ",(0,r.kt)("em",{parentName:"p"},"(or rather RFID)")," capabilities."),(0,r.kt)("p",null,"It provides the following platform-tag-classes:"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"Type"),(0,r.kt)("th",{parentName:"tr",align:"center"},"Android"),(0,r.kt)("th",{parentName:"tr",align:"center"},"iOS"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Ndef"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"FeliCa"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Iso7816"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"Iso15693"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MiFare"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NfcA"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NfcB"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NfcF"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NfcV"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"IsoDep"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MifareClassic"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"MifareUltralight"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"NdefFormatable"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u2705"),(0,r.kt)("td",{parentName:"tr",align:"center"},"\u274c")))),(0,r.kt)("p",null,"As you can see, the only type that is available on both platforms is NDEF. And that is expectable, as this is the standardized format for NFC Forum Tags."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("mdxAdmonitionTitle",{parentName:"admonition"},(0,r.kt)("a",{parentName:"mdxAdmonitionTitle",href:"https://nfc-forum.org/what-is-nfc/about-the-technology/"},"https://nfc-forum.org/what-is-nfc/about-the-technology/")),(0,r.kt)("p",{parentName:"admonition"},"NFC Forum Tags are contact-less memory cards hosting a so called NDEF message (NDEF is standing for NFC Data Exchange Format) defined by an NFC Forum Specification. NFC Forum has currently defined five different NFC Forum Tag types to allow the usage of many different existing memory card implementations as NFC Forum Tags. These different NFC Forum Tag types differ by the underlying communication protocol and data structure to store NDEF messages but the resulting overall behavior of NFC Forum Tags is identical.")),(0,r.kt)("p",null,"That means if we want to go cross-platform, we should use NDEF-compatible cards. This can be a problem on its own \u2013 when we were looking for the cards for our project, we failed to find them."),(0,r.kt)("p",null,"At least we managed to find Mifare Desfire EV1 which can be formatted to NDEF format, but it can only be done with Android. So it's either formatting the cards in advance and then using any mobile phone for writing NDEF messages, or using Android for writing the data (later both iPhone and Android can be used for reading the data)."),(0,r.kt)("p",null,"We decided to choose the second way, as Android has some other advantages for serving as an improvised key cutter."),(0,r.kt)("h2",{id:"ios-vs-android--ux-custom-behavior"},"iOS vs Android \u2013 UX, custom behavior"),(0,r.kt)("p",null,'If you have an NDEF-formatted card, you can read and write using both Android and iPhone. But we didn\'t need a "B2C"-style app, we were going to create a key cutter emulator. And for this, Android is a better choice:'),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"iOS supports NDEF-formatted cards, while Android can also operate on so-called NDEF-formattable cards, formatting them and writing NDEF messages (after that it can be read by iOS as well);"),(0,r.kt)("li",{parentName:"ul"},"iOS displays a system dialog when initiating an NFC session. Android allows you to do the scanning in the background, providing a clearer experience;"),(0,r.kt)("li",{parentName:"ul"},"there's one advantage in iOS devices though, at least among the devices I've tested. The NFC-reader is more sensitive and can read/write data when you touch the front side of the device.")),(0,r.kt)("h2",{id:"implementation"},"Implementation"),(0,r.kt)("p",null,'The "key cutting" logic is pretty simple: we\'re just connecting to the server and waiting for the command. After the command is received, we fetch additional data (since the command itself contains only the room number, we need to fetch the reservation details) and validate them (it should point to the correct active reservation). If the data are valid, we start an NFC writing session: enter discovering tag mode, and write the data (room number in our case) after the tag is discovered (aka NFC-card bumped to the phone). After that, we return to the "waiting" state, and the process repeats.'),(0,r.kt)("mermaid",{value:'stateDiagram-v2\n    direction LR\n\n    state Validating <<choice>>\n    state "NFC writing session" as WriteSession\n    state "Waiting for command" as Waiting\n\n    [*] --\x3e Waiting\n    Waiting --\x3e FetchingData: Command received\n    FetchingData --\x3e Validating\n    Validating --\x3e Waiting: Invalid\n    Validating --\x3e WriteSession: Valid\n\n    state WriteSession {\n        [*] --\x3e DiscoveringTag\n        DiscoveringTag --\x3e Writing\n        Writing --\x3e [*]\n    }\n\n    WriteSession --\x3e Waiting'}),(0,r.kt)("p",null,"This state diagram can be easily mapped to the BLoC code, so let's just take a look at the NFC writing part:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"Future<void> _writeNumber(String number) {\n  final completer = Completer<void>();\n\n  NfcManager.instance.startSession(\n    onDiscovered: (tag) async {\n      final ndef = Ndef.from(tag);\n      final formattable = NdefFormatable.from(tag);\n\n      final message = NdefMessage([NdefRecord.createText(number)]);\n      if (ndef != null) {\n        await ndef.write(message);\n      } else if (formattable != null) {\n        await formattable.format(message);\n      }\n      await NfcManager.instance.stopSession();\n      completer.complete();\n    },\n    onError: (error) async => completer.completeError(error),\n  );\n\n  return completer.future;\n}\n")),(0,r.kt)("p",null,"As you see, we're starting an NFC session, and passing it a callback as ",(0,r.kt)("inlineCode",{parentName:"p"},"onDiscovered")," parameter \u2013 it will be triggered once an NFC trigger detects a tag nearby. As I mentioned earlier, in Android we can work with either NDEF or NDEF formattable tags, so if the tag of the correct type was bumped, we just write the prepared message there (which contains just the the room number in our case) and close the session."),(0,r.kt)("p",null,"The code for the reading part of the app is pretty straightforward as well. I will show the complete source code for the ",(0,r.kt)("inlineCode",{parentName:"p"},"NfcReaderBloc"),", but the most interesting part is the ",(0,r.kt)("inlineCode",{parentName:"p"},"_onTagDiscovered")," method:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"typedef _Event = NfcReaderEvent;\ntypedef _State = NfcReaderState;\ntypedef _EventHandler = EventHandler<_Event, _State>;\ntypedef _Emitter = Emitter<_State>;\n\nclass NfcReaderBloc extends Bloc<_Event, _State> {\n  NfcReaderBloc() : super(const Waiting()) {\n    on<_Event>(_eventHandler, transformer: droppable());\n\n    NfcManager.instance.startSession(\n      onDiscovered: (tag) async => add(TagDiscovered(tag)),\n      onError: (e) async => add(Failed(e)),\n    );\n  }\n\n  _EventHandler get _eventHandler => (event, emit) => event.map(\n        tagDiscovered: (event) => _onTagDiscovered(event, emit),\n        failed: (event) => _onFailed(event, emit),\n      );\n\n  Future<void> _onTagDiscovered(TagDiscovered event, _Emitter emit) async {\n    try {\n      final ndef = Ndef.from(event.tag);\n      if (ndef == null) throw Exception('No NDEF tag');\n\n      final data = await ndef.read();\n\n      emit(Success(utf8.decode(data.records.first.payload).substring(3)));\n    } on Object {\n      emit(const Failure());\n    }\n\n    await Future<void>.delayed(const Duration(seconds: 3));\n    emit(const Waiting());\n  }\n\n  Future<void> _onFailed(Failed _, _Emitter emit) async {\n    emit(const Failure());\n    await Future<void>.delayed(const Duration(seconds: 3));\n    emit(const Waiting());\n  }\n\n  @override\n  Future<void> close() {\n    NfcManager.instance.stopSession();\n\n    return super.close();\n  }\n}\n\n@freezed\nclass NfcReaderEvent with _$NfcReaderEvent {\n  const factory NfcReaderEvent.tagDiscovered(NfcTag tag) = TagDiscovered;\n  const factory NfcReaderEvent.failed(NfcError e) = Failed;\n}\n\n@freezed\nclass NfcReaderState with _$NfcReaderState {\n  const factory NfcReaderState.waiting() = Waiting;\n  const factory NfcReaderState.success(String number) = Success;\n  const factory NfcReaderState.failure() = Failure;\n}\n")),(0,r.kt)("p",null,"As you see, when the tag is discovered, we just read the first record there (assuming that we read the NDEF formatted tag) and emit it as a new state. The only trick here is to skip the first three bytes of the payload. This is needed because, according to the NDEF specification, the first byte in the payload is reserved to store the length of the language code (N), then goes N bytes to store the language code itself, and then the actual record content (our message). In our case, we only use EN language (two bytes for the code), so we can hard-code to skip the three reserved bytes."),(0,r.kt)("h2",{id:"demo"},"Demo"),(0,r.kt)("video",{controls:!0,width:"100%"},(0,r.kt)("source",{src:"/kiosk.mp4"})),(0,r.kt)("hr",null),(0,r.kt)("p",null,"The result was pretty good and we received a lot of positive feedback, so we decided to reuse this idea for WebExpo 2022, but that's a different story."))}m.isMDXComponent=!0},1582:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/key_cutter-09eeeb88fc88e181792a82fa252ca760.jpg"},3493:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/key_cutting_kiosk-f233242f55301d7cb161268f9f7cc9b0.png"},2794:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/thumb-c1d18a6acbf6a03118b945d6dd1773d4.jpg"}}]);