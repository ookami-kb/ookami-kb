"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8241],{8729:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var a=n(7462),i=(n(7294),n(3905));n(1839);const r={title:"UI tests in Flutter with Azure Pipelines"},o=void 0,s={permalink:"/ru/blog/2020/06/15/ci-azure",source:"@site/blog/2020-06-15-ci-azure/index.md",title:"UI tests in Flutter with Azure Pipelines",description:"Continuous integration (CI) is the practice of merging all developers\u2019 working copies to shared mainline several times a day.",date:"2020-06-15T00:00:00.000Z",formattedDate:"15 \u0438\u044e\u043d\u044f 2020 \u0433.",tags:[],readingTime:6.755,hasTruncateMarker:!0,authors:[],frontMatter:{title:"UI tests in Flutter with Azure Pipelines"},prevItem:{title:"13 reasons why Dart is worse than Kotlin",permalink:"/ru/blog/2020/07/20/dart-vs-kotlin"},nextItem:{title:"Intro to Flutter: a practical guide to cross-platform development",permalink:"/ru/blog/2020/05/19/intro-to-flutter"}},l={authorsImageUrls:[]},d=[{value:"Install Flutter",id:"install-flutter",level:2},{value:"Install AVD",id:"install-avd",level:3},{value:"Screen recording",id:"screen-recording",level:2},{value:"Run tests",id:"run-tests",level:2},{value:"Download record",id:"download-record",level:2},{value:"Pipeline configuration",id:"pipeline-configuration",level:2}],p={toc:d};function u(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Continuous integration (CI) is the practice of merging all developers\u2019 working copies to shared mainline several times a day.")),(0,i.kt)("p",null,"One of the most important aspects of CI is keeping the mainline healthy. That\u2019s why it\u2019s crucial to have proper tests, both unit and UI, that can run against any PR and/or commit to the mainline. At the same time, these tests should also be fast. It\u2019s usually not a problem with unit tests, but UI tests, especially if you want to run them on multiple devices, can take a rather long time."),(0,i.kt)("p",null,"As a balance between speed and reliability, for PRs into the mainline, we use smoke UI tests that only prove the main functionality is working. Proper UI testing with manual QA verification is done only when we\u2019re preparing a new release candidate."),(0,i.kt)("p",null,"In this article, I will show you how we\u2019ve set up Azure Pipelines for running automated UI smoke tests for a Flutter app."),(0,i.kt)("hr",null),(0,i.kt)("p",null,"Unfortunately, Azure Pipelines don\u2019t provide agents with Flutter pre-installed, and, as we use Microsoft-hosted agents, we need to perform a bunch of actions on each job run (you can avoid these steps by setting up and using ",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/v2-osx?view=azure-devops"},"self-hosted agents"),"). These actions are simpler to invoke as bash scripts, so almost every step in pipeline configuration just delegates the work to some script."),(0,i.kt)("p",null,"We keep these scripts in a separate file:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell",metastring:'title="pipelines/scripts.sh"',title:'"pipelines/scripts.sh"'},'#!/bin/sh\n\nset -e\nexport PATH=$BUILD_SOURCESDIRECTORY/flutter/bin:$BUILD_SOURCESDIRECTORY/flutter/bin/cache/dart-sdk/bin:$PATH\n\n# All scripts will be placed here\n\n"$@"\n')),(0,i.kt)("p",null,"We use the ",(0,i.kt)("inlineCode",{parentName:"p"},"set -e")," option, so that each failed command will fail the job, then add the Flutter installation directory to ",(0,i.kt)("inlineCode",{parentName:"p"},"$PATH"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},'"$@"')," allows us to use functions defined in this file in other scripts \u2014 if we have a function ",(0,i.kt)("inlineCode",{parentName:"p"},"install_flutter()")," defined in this file, we can call it later with ",(0,i.kt)("inlineCode",{parentName:"p"},"sh scripts.sh install_flutter"),"."),(0,i.kt)("h2",{id:"install-flutter"},"Install Flutter"),(0,i.kt)("p",null,"First, we need to install Flutter:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"install_flutter() {\n  git clone -b stable https://github.com/flutter/flutter.git\n\n  flutter precache\n  yes | $ANDROID_HOME/tools/bin/sdkmanager --licenses\n  flutter doctor\n}\n")),(0,i.kt)("p",null,"Here we download a stable branch of Flutter, install it, accept all licenses, and print doctor output (you can skip this, but it can be useful to check when dealing with certain problems)."),(0,i.kt)("h3",{id:"install-avd"},"Install AVD"),(0,i.kt)("p",null,"Next, install and launch AVD:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},'launch_avd() {\n  echo "Installing SDK"\n  $ANDROID_HOME/tools/bin/sdkmanager --install \'system-images;android-29;default;x86\'\n\n  echo "Creating emulator"\n  $ANDROID_HOME/tools/bin/avdmanager create avd -n "pixel" --device "pixel" -k "system-images;android-29;default;x86"\n\n  echo "Starting emulator"\n  $ANDROID_HOME/emulator/emulator -avd "pixel" -no-snapshot &\n  $ANDROID_HOME/platform-tools/adb wait-for-device shell \'while [[ -z $(getprop sys.boot_completed | tr -d \'\\r\') ]]; do sleep 1; done; input keyevent 82\'\n\n  echo "Emulator started"\n}\n')),(0,i.kt)("p",null,"We use Android SDK 29 without Google APIs. You can use a different SDK, just replace ",(0,i.kt)("inlineCode",{parentName:"p"},"'system-images;android-29;default;x86'")," with the other option. You can get a full list of options by running ",(0,i.kt)("inlineCode",{parentName:"p"},"sdkmanager --list | grep system-images | sort | uniq"),"."),(0,i.kt)("h2",{id:"screen-recording"},"Screen recording"),(0,i.kt)("p",null,"In Google Play automated tests there\u2019s a cool feature: it records the screen while running tests, so you can download and check it later. It\u2019s a good idea to have it in our tests as well. For that, we can use the built-in ",(0,i.kt)("inlineCode",{parentName:"p"},"screenrecord")," utility. Unfortunately, it has a hard-coded max length of three minutes. So we need a hack to fix this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"start_recording() {\n  # Each video is 3 minutes max, so 5 videos will give us up to 15 minutes,\n  # should be enough for test\n  $ANDROID_HOME/platform-tools/adb shell mkdir /sdcard/video\n  $ANDROID_HOME/platform-tools/adb shell screenrecord /sdcard/video/1.mp4\n  $ANDROID_HOME/platform-tools/adb shell screenrecord /sdcard/video/2.mp4\n  $ANDROID_HOME/platform-tools/adb shell screenrecord /sdcard/video/3.mp4\n  $ANDROID_HOME/platform-tools/adb shell screenrecord /sdcard/video/4.mp4\n  $ANDROID_HOME/platform-tools/adb shell screenrecord /sdcard/video/5.mp4\n}\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"No worries, this doesn\u2019t mean that all five records will be created with each job \u2014 we\u2019ll stop recording once tests are done.")),(0,i.kt)("h2",{id:"run-tests"},"Run tests"),(0,i.kt)("p",null,"Now we\u2019re ready to create a script that will build and run tests:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"flutter_test() {\n  flutter packages get\n  flutter packages pub run build_runner build\n\n  flutter test\n\n  launch_avd\n  start_recording &\n  flutter drive --target=test_driver/app.dart\n  pkill -f screenrecord || true\n}\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"If you don\u2019t have any code generation in your project, remove the ",(0,i.kt)("inlineCode",{parentName:"p"},"build_runner")," action.")),(0,i.kt)("p",null,"This script runs unit tests with ",(0,i.kt)("inlineCode",{parentName:"p"},"flutter test")," and UI tests with ",(0,i.kt)("inlineCode",{parentName:"p"},"flutter drive --target=test_driver/app.dart"),". As you can see here, before running UI tests we launch AVD and start video recording in the background. And after the test is done, we kill the running ",(0,i.kt)("inlineCode",{parentName:"p"},"screenrecord")," command. Thanks to the ",(0,i.kt)("inlineCode",{parentName:"p"},"set -e")," option defined in the script, it will also end the ",(0,i.kt)("inlineCode",{parentName:"p"},"start_recording")," command."),(0,i.kt)("h2",{id:"download-record"},"Download record"),(0,i.kt)("p",null,"We also need a helper script for getting the record out of the device:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-shell"},"pull_video() {\n  $ANDROID_HOME/platform-tools/adb pull /sdcard/video $BUILD_SOURCESDIRECTORY/screenshots\n}\n")),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"If you provide a directory as the pull argument it will download all files in that directory.")),(0,i.kt)("h2",{id:"pipeline-configuration"},"Pipeline configuration"),(0,i.kt)("p",null,"Now let\u2019s create a pipeline configuration file putting everything together:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-yaml"},'trigger: none\npr:\n  - master\n\njobs:\n  - job: Test\n    timeoutInMinutes: 20\n    pool:\n      vmImage: "macOS-latest"\n    steps:\n      - script: pipelines/scripts.sh install_flutter\n        displayName: Install Flutter\n      - script: pipelines/scripts.sh flutter_test\n        displayName: Test app\n      - script: ../pipelines/scripts.sh pull_video\n        displayName: Pull screen video record\n        condition: always()\n      - task: PublishBuildArtifacts@1\n        displayName: Publish screenshots\n        condition: always()\n        inputs:\n          pathtoPublish: "$(System.DefaultWorkingDirectory)/screenshots/"\n          artifactName: screenshots\n')),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"If you\u2019re not sure where to put this file, check ",(0,i.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/en-us/azure/devops/pipelines/create-first-pipeline"},"this tutorial"),".")),(0,i.kt)("hr",null),(0,i.kt)("p",null,"What about the UI test itself? Let\u2019s create a basic smoke test that allows us to check the app state (you can find a detailed tutorial on the ",(0,i.kt)("a",{parentName:"p",href:"https://flutter.dev/docs/cookbook/testing/integration/introduction"},"official site"),")."),(0,i.kt)("p",null,"First, create a ",(0,i.kt)("inlineCode",{parentName:"p"},"test_driver")," folder and put an ",(0,i.kt)("inlineCode",{parentName:"p"},"app.dart")," file into it with the following content:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-dart",metastring:'title="test_driver/app.dart"',title:'"test_driver/app.dart"'},"import 'package:commander/main.dart' as app;\nimport 'package:flutter_driver/driver_extension.dart';\n\nvoid main() {\n  enableFlutterDriverExtension();\n  app.main();\n}\n")),(0,i.kt)("p",null,'This file contains an "instrumented" version of the app. While it can have any name that makes sense, for the sake of simplicity we just call it ',(0,i.kt)("inlineCode",{parentName:"p"},"app.dart"),"."),(0,i.kt)("p",null,"Now let\u2019s create a file that contains the test suite which drives the app and verifies that it works as expected. The name of the test file must correspond to the name of the file that contains the instrumented app, with ",(0,i.kt)("inlineCode",{parentName:"p"},"_test")," added at the end. In our case, it means that name should be ",(0,i.kt)("inlineCode",{parentName:"p"},"app_test.dart"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-dart"},"import 'dart:io';\n\nimport 'package:flutter_driver/flutter_driver.dart';\nimport 'package:test/test.dart';\n\nimport 'app_test_resources.dart';\n\nvoid main() {\n  group('Smoke tests', () {\n    FlutterDriver driver;\n\n    // Connect to the Flutter driver before running any tests.\n    setUpAll(() async {\n      driver = await FlutterDriver.connect();\n      await Directory('screenshots').create();\n    });\n\n    // Close the connection to the driver after the tests have completed.\n    tearDownAll(() async {\n      if (driver != null) {\n        await driver.close();\n      }\n    });\n\n    test('Commander Walkthrough', () async {\n      await loginToCommander(driver);\n      await goToMessages(driver);\n      await goToTasks(driver);\n      await goToProfile(driver);\n      await goToRooms(driver);\n    }, timeout: const Timeout(Duration(minutes: 1)));\n  });\n}\n")),(0,i.kt)("p",null,"As you can see, in the ",(0,i.kt)("inlineCode",{parentName:"p"},"setUpAll")," function we create screenshots directory \u2014 we will put screenshots there if needed (and screen recording as well)."),(0,i.kt)("p",null,"All the helper functions, such as ",(0,i.kt)("inlineCode",{parentName:"p"},"loginToCommander")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"goToRooms")," are defined in the ",(0,i.kt)("inlineCode",{parentName:"p"},"app_test_resources.dart")," file, e.g.:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-dart"},"Future<void> goToRooms(FlutterDriver driver) async {\n  await driver.tap(find.byValueKey('rooms'));\n  await driver.assertElementPresent('sliverList');\n  await driver.assertElementPresent('floorHeader');\n}\n")),(0,i.kt)("p",null,"We also have a couple of extensions for the driver:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-dart"},"import 'dart:io';\n\nimport 'package:flutter_driver/flutter_driver.dart';\n\nextension DriverExt on FlutterDriver {\n  Future<void> saveScreenshot() async {\n    final path = 'screenshots/'\n        '${DateTime.now().toIso8601String().replaceAll(':', '-')}'\n        '.png';\n    final List<int> pixels = await screenshot();\n    final file = File(path);\n    await file.writeAsBytes(pixels);\n  }\n\n  Future<void> assertElementPresent(\n    String valueKey, {\n    Duration timeout = const Duration(seconds: 5),\n  }) async {\n    try {\n      return await waitFor(find.byValueKey(valueKey), timeout: timeout);\n      // ignore: avoid_catching_errors\n    } on DriverError catch (_) {\n      await saveScreenshot();\n      rethrow;\n    }\n  }\n}\n")),(0,i.kt)("admonition",{type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"We replace \u201c:\u201d with \u201c-\u201d in the file name because Azure Pipelines fails to publish a file to artifacts if it contains \u201c:\u201d in the name.")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"saveScreenshot")," is called automatically when the driver fails to find an element. In that case, we want to be able to look at a screenshot and figure out what the problem is. It can also be called manually if we want to screenshot the app at some checkpoint."),(0,i.kt)("p",null,"Here\u2019s the downloaded video with screen recording:"),(0,i.kt)("p",null,(0,i.kt)("img",{src:n(4016).Z,width:"435",height:"774"})),(0,i.kt)("p",null,"That\u2019s it for running our UI tests on an Android emulator. Although, despite the cross-platform nature of Flutter, it could be useful to run these smoke tests on an iOS simulator as well, right? But that\u2019s a topic for another article. Stay tuned ;)"))}u.isMDXComponent=!0},4016:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/demo-09a219d0294c122c6ff8a8acb03c2b33.gif"}}]);