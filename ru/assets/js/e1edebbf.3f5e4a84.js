"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[1525],{3905:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),c=d(a),h=r,m=c["".concat(l,".").concat(h)]||c[h]||u[h]||o;return a?n.createElement(m,i(i({ref:t},p),{},{components:a})):n.createElement(m,i({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var d=2;d<o;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},7283:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var n=a(7462),r=(a(7294),a(3905));const o={title:"Intro to Flutter: a practical guide to cross-platform development"},i=void 0,s={permalink:"/ru/blog/2020/05/19/intro-to-flutter",source:"@site/blog/2020-05-19-intro-to-flutter/index.md",title:"Intro to Flutter: a practical guide to cross-platform development",description:"Today I would like to share with you our experience with running our Flutter application in production for about 6 months. We will talk about how to organize your code, which libraries to use and other tips and tricks we\u2019ve learned so far.",date:"2020-05-19T00:00:00.000Z",formattedDate:"19 \u043c\u0430\u044f 2020 \u0433.",tags:[],readingTime:25.745,hasTruncateMarker:!0,authors:[],frontMatter:{title:"Intro to Flutter: a practical guide to cross-platform development"},prevItem:{title:"UI tests in Flutter with Azure Pipelines",permalink:"/ru/blog/2020/06/15/ci-azure"},nextItem:{title:"Flutter for Web: is it a killer of React?",permalink:"/ru/blog/2020/01/29/flutter-web"}},l={authorsImageUrls:[]},d=[{value:"Cross-platform development: are we there yet?",id:"cross-platform-development-are-we-there-yet",level:2},{value:"Cross-platform development: advantages",id:"cross-platform-development-advantages",level:3},{value:"Cross-platform development: drawbacks",id:"cross-platform-development-drawbacks",level:3},{value:"Approaches: there are 14 competing standards\u2026",id:"approaches-there-are-14-competing-standards",level:2},{value:"Approaches: hybrid apps",id:"approaches-hybrid-apps",level:3},{value:"Approaches: native UI",id:"approaches-native-ui",level:3},{value:"Approaches: share business logic",id:"approaches-share-business-logic",level:3},{value:"Approaches: Flutter",id:"approaches-flutter",level:3},{value:"Flutter in Mews: love story\u2026",id:"flutter-in-mews-love-story",level:2},{value:"Flutter in Mews: Commander",id:"flutter-in-mews-commander",level:3},{value:"Libraries to use without going into dependency hell\u2026",id:"libraries-to-use-without-going-into-dependency-hell",level:2},{value:"Libraries to use: RX",id:"libraries-to-use-rx",level:3},{value:"Libraries to use: immutability",id:"libraries-to-use-immutability",level:3},{value:"Libraries to use: JSON",id:"libraries-to-use-json",level:3},{value:"Libraries to use: API",id:"libraries-to-use-api",level:3},{value:"Libraries to use: DI",id:"libraries-to-use-di",level:3},{value:"Architecture / Structure: 10,000 foot overview",id:"architecture--structure-10000-foot-overview",level:2},{value:"Structure",id:"structure",level:3},{value:"Architecture",id:"architecture",level:3},{value:"Other tips. TLDR: do it well",id:"other-tips-tldr-do-it-well",level:2},{value:"Code style",id:"code-style",level:3},{value:"Static analysis",id:"static-analysis",level:3},{value:"Extract widgets",id:"extract-widgets",level:3},{value:"Logging",id:"logging",level:3}],p={toc:d};function u(e){let{components:t,...o}=e;return(0,r.kt)("wrapper",(0,n.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Today I would like to share with you our experience with running our Flutter application in production for about 6 months. We will talk about how to organize your code, which libraries to use and other tips and tricks we\u2019ve learned so far."),(0,r.kt)("p",null,"This is actually a text version of my ",(0,r.kt)("a",{parentName:"p",href:"https://youtu.be/P1SLlW-kIp4"},"online presentation")," \u2013 for those who (like me) prefer reading to watching and listening."),(0,r.kt)("h2",{id:"cross-platform-development-are-we-there-yet"},"Cross-platform development: are we there yet?"),(0,r.kt)("p",null,"First of all, let\u2019s talk about ",(0,r.kt)("a",{parentName:"p",href:"https://developers.mews.com/multiplatform-apps-are-we-there-yet/"},"cross-platform development")," in general. Why are there so many cross-platform frameworks, why does each framework promise to kill native development, and why, despite all of that, is native development still alive?"),(0,r.kt)("h3",{id:"cross-platform-development-advantages"},"Cross-platform development: advantages"),(0,r.kt)("p",null,"Let\u2019s define which advantages we can get when doing cross-platform development."),(0,r.kt)("p",null,"First of all, it\u2019s of course ",(0,r.kt)("strong",{parentName:"p"},"reusing business logic"),". We programmers are lazy folk, so if something can be done once, we would like to have it done once. Especially when it comes to business logic \u2013 the core of our application, something that should be tested thoroughly and at the same time something that can be changed constantly over time."),(0,r.kt)("p",null,"Second, ",(0,r.kt)("strong",{parentName:"p"},"reusing UI"),". Now, this can be a controversial moment and actually some developers and designers can argue that UI should be as strictly adhering to platform guidelines as possible. At the same time it\u2019s pretty common lately to have a unified \u201cbranded\u201d UI that is the same across all platforms, and platforms themselves are eliminating differences in both UI and UX."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Faster development cycle"),". Obviously, if we need to implement a feature only once, it\u2019s faster than to implement it twice. Of course, if we\u2019re speaking about a full development cycle starting from product discovery through design and up to coding, testing and deployment \u2013 we won\u2019t get 2x speed up, as there still are some steps that cannot be shared; but there will be a gain in time anyway."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Smaller teams"),". Maybe, as developers, we\u2019re not interested in having less demand for our services, but tech leads and other managers will definitely consider it as an advantage. And the benefit here is growing at a rapid pace. Managing a team of 3 people is more than 2 times simpler than managing a team of 6 people: with scaling team down intercommunication problems are scaled down faster."),(0,r.kt)("p",null,"And the last, but not least point: ",(0,r.kt)("strong",{parentName:"p"},"synchronized releases"),". As you develop a new feature only once, there is a high chance that it can be tested and deployed at almost the same time: almost, because e.g. Apple pre-moderation can take up to several days. And it makes life easier for the marketing team, product managers, and the support team since users have a higher chance of getting the same latest version of your app at the same period of time."),(0,r.kt)("p",null,"So, is life that beautiful for cross-platform developers? Well, obviously not."),(0,r.kt)("h3",{id:"cross-platform-development-drawbacks"},"Cross-platform development: drawbacks"),(0,r.kt)("p",null,"Let\u2019s now take a look at drawbacks we can have with a cross-platform approach. First, no matter how good a cross-platform framework can be, we still will have only a ",(0,r.kt)("strong",{parentName:"p"},"subset of features")," available to native developers. If we want unified experience, then we obviously lose features that are unique to each platform."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Non-native UX"),". Though it can be solved in some frameworks with different methods, if we start to strictly follow platform UX guidelines we can lose one of the advantages \u2013 reusing UI/UX across platforms."),(0,r.kt)("p",null,"One of the most important problems with cross-platform frameworks \u2013 at least with some of them \u2013 is a ",(0,r.kt)("strong",{parentName:"p"},"performance penalty"),". If there will be another abstraction layer, there will be another performance degradation. Or not? Let\u2019s talk about it in a moment."),(0,r.kt)("p",null,"And the last moment, which is maybe not a drawback, but just a point to keep in mind. Some managers think that 1 cross-platform developer = 1 iOS developer + 1 Android developer. That\u2019s not true, in my opinion. No matter how good a cross-platform framework is, sooner or later there will be some problem in interop with some platform. And at that moment it\u2019s better to have a developer who has a ",(0,r.kt)("strong",{parentName:"p"},"native experience")," with this platform."),(0,r.kt)("p",null,"Anyway, it's a never ending discussion \u2013 whether cross-platform development is good or bad. The right answer sounds familiar to all architects: it depends. But for now I just assume that you\u2019re at least interested in cross-platform development, so let\u2019s continue talking about it."),(0,r.kt)("h2",{id:"approaches-there-are-14-competing-standards"},"Approaches: there are 14 competing standards\u2026"),(0,r.kt)("p",null,"I would like to speak about different \u201ccategories\u201d of cross-platform framework that we can find. These are very loose categories divided by the way they deal with UI."),(0,r.kt)("h3",{id:"approaches-hybrid-apps"},"Approaches: hybrid apps"),(0,r.kt)("p",null,"My first category would be frameworks for creating hybrid apps. By that we usually mean a WebView with a common HTML/CSS/JS app that is placed inside some native wrapper which also provides an access to native platform features, e.g. camera or geolocation. These are such frameworks as PhoneGap, Ionic or Onsen UI."),(0,r.kt)("p",null,"And since it\u2019s just an HTML application inside, it\u2019s very ",(0,r.kt)("strong",{parentName:"p"},"easy for web developers")," to dive into mobile applications development, or to reuse your web application, or create some prototype."),(0,r.kt)("p",null,"At the same time the main disadvantages are really ",(0,r.kt)("strong",{parentName:"p"},"bad performance")," \u2013 due to a huge number of abstraction layers \u2013 and ",(0,r.kt)("strong",{parentName:"p"},"non-native UI")," \u2013 no matter how hard you try you will hardly make users believe that this is a native app."),(0,r.kt)("h3",{id:"approaches-native-ui"},"Approaches: native UI"),(0,r.kt)("p",null,"Next category, which for convenience I\u2019ve called \u201cnative UI\u201d, is presented by such frameworks as Xamarin, React Native or Titanium. Their common feature is that they seamlessly provide you the way to use ",(0,r.kt)("strong",{parentName:"p"},"native UI")," components in your cross-platform application."),(0,r.kt)("p",null,"What does it look like? You develop an application in your favorite language \u2013 JS/TypeScript/C#. Your business logic can of course be totally shared, and the UI is translated into native UI of each platform."),(0,r.kt)("p",null,"The disadvantage of this approach is again a ",(0,r.kt)("strong",{parentName:"p"},"performance impact"),". So not as big as in the previous category, it can still be a problem. For example, Xamarin application requires the whole .Net mono runtime to launch your application. For some old and cheap Android devices it can be a hard burden. React Native also creates a bridge to translate your javascript code into native calls and back \u2013 which can be quite expensive, especially when we speak about animations."),(0,r.kt)("h3",{id:"approaches-share-business-logic"},"Approaches: share business logic"),(0,r.kt)("p",null,"There is another approach, which was taken e.g. by Kotlin Multiplatform framework: it allows you to share your BL written in Kotlin between your Android and iOS app. It will be compiled for JVM runtime for Android and into native code for iOS app, which we can call from Swift code thanks to interop feature without any significant performance impact. Both an advantage and drawback (depending on the way you look at it) of this approach is that you have to implement UI for each platform separately, using native methods."),(0,r.kt)("h3",{id:"approaches-flutter"},"Approaches: Flutter"),(0,r.kt)("p",null,"And now let\u2019s talk about the approach that was chosen by the main hero of this article. Strictly speaking this approach is not unique: there is at least another one framework I know with the similar way: it\u2019s Kivy \u2013 cross-platform framework in Python."),(0,r.kt)("p",null,"The main idea is that the framework does all the UI rendering on its side (slightly similar to our first category), but using a high performance rendering engine under the hood. In case of Flutter it\u2019s Skia: an open-source 2D graphics library that serves as the graphics engine for Google Chrome and Chrome OS, Android itself and some other products."),(0,r.kt)("p",null,"So, what do we gain when using Flutter? We can ",(0,r.kt)("strong",{parentName:"p"},"share code")," for our business logic \u2013 well, that\u2019s obvious. Next, we can ",(0,r.kt)("strong",{parentName:"p"},"share UI")," \u2013 as the rendering is done by the framework, we have a number of options here: to have unified UI across platforms, to use natively looking components on each platform or even some crazy combination, such as Cupertino components on Android and Material components on iOS (yeah, it can sound weird, but we actually use this mix in our UI library \u2013 some of our components are based on Material ones, while another on Cupertino)."),(0,r.kt)("p",null,"Yes, it's worth noting here that these components are not native ones \u2013 they only look like native components, but they were implemented from scratch in the default library."),(0,r.kt)("p",null,"What else? As I\u2019ve already mentioned thanks to this graphics engine we can get a very ",(0,r.kt)("strong",{parentName:"p"},"high performance")," of 60 FPS even for complex animations."),(0,r.kt)("p",null,"And because all the components are implemented from scratch, we get a really nice UI system built on ",(0,r.kt)("strong",{parentName:"p"},"composition over inheritance")," and ",(0,r.kt)("strong",{parentName:"p"},"functional composition")," principles. As for me this UI system is really great, compared to iOS and especially the Android system of widgets and views."),(0,r.kt)("p",null,"And the last point, and the most controversial one. Flutter is using ",(0,r.kt)("strong",{parentName:"p"},"Dart")," language, and so will you. I know some people who hate this language, I didn\u2019t have any good feelings about it as well at the beginning, but now I even start to like some of its features. Well, maybe it\u2019s just a Stockholm syndrome."),(0,r.kt)("p",null,"Anyway, let\u2019s now talk about Flutter in Mews."),(0,r.kt)("h2",{id:"flutter-in-mews-love-story"},"Flutter in Mews: love story\u2026"),(0,r.kt)("p",null,"In Mews we love Flutter. And I\u2019m not only speaking for myself, honestly. We use it for developing a light mobile version of our PMS: the one that I\u2019ll be talking about in a moment."),(0,r.kt)("p",null,"Another Flutter project that I\u2019ve already mentioned is the UI library. We have big plans about open-sourcing it in the near future, so stay tuned."),(0,r.kt)("p",null,"We are also using Flutter for different side projects: both to play with Flutter and to try some approaches that can be incorporated into our main app."),(0,r.kt)("p",null,"And we are actively participating and organizing different meetups and workshops about Flutter, and writing ",(0,r.kt)("a",{parentName:"p",href:"https://developers.mews.com/flutter-how-to-draw-text-along-arc/"},"blog posts"),"."),(0,r.kt)("p",null,"So let\u2019s now talk about our main Flutter application."),(0,r.kt)("h3",{id:"flutter-in-mews-commander"},"Flutter in Mews: Commander"),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(5339).Z,width:"2000",height:"2000"})),(0,r.kt)("p",null,"This app is a light version of our PMS that is for now mainly used by housekeepers and maintenance staff. From the developer point of view it implements the common set of features of business applications: calling APIs and displaying dynamic forms, receiving real-time updates via push notifications and websockets, managing localisations and so on."),(0,r.kt)("p",null,"Speaking of the team, we can say it was built by 1.5 developers. Originally it was only me, then we\u2019ve got another developer, but at the same time I was doing other tasks and didn\u2019t take an active part in development, mainly in code review."),(0,r.kt)("p",null,"The development started in April 2019 \u2013 we had an old version of this app written natively in Java for Android and Swift for iOS \u2013 but it was not actively developed and the Android version required some major refactoring, so we decided to rewrite it from scratch in Flutter."),(0,r.kt)("p",null,"The first public release was in September 2019 and it\u2019s still under active development \u2013 we\u2019re releasing a new version of the app roughly each 2-weeks (once per sprint)."),(0,r.kt)("p",null,"Currently, we have only about 3K active users monthly, but we have a lot of plans to improve it, so we\u2019re steadily growing our user base."),(0,r.kt)("p",null,"So, what have we learned so far, having this app in production for about half a year? First, let\u2019s talk about the most useful libraries we\u2019re using there and in pretty much every other Flutter project, either big or small."),(0,r.kt)("h2",{id:"libraries-to-use-without-going-into-dependency-hell"},"Libraries to use without going into dependency hell\u2026"),(0,r.kt)("h3",{id:"libraries-to-use-rx"},"Libraries to use: RX"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"dependencies:\n  rxdart: ^0.24.1\n")),(0,r.kt)("p",null,"If there is a family of libraries that doesn\u2019t need any introduction, then it should be Rx","*",". You probably know its implementations for different languages such as ",(0,r.kt)("inlineCode",{parentName:"p"},"RxJava")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"RxKotlin"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"RxSwift"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"RxJS"),". Dart is not an exception here and we have a rxdart library. Though there are built-in streams in Dart and many concepts in Flutter are built around Streams, this library gives a lot of extensions and helper functions on top of these native streams and is highly recommended, especially if you were using other implementations before."),(0,r.kt)("h3",{id:"libraries-to-use-immutability"},"Libraries to use: immutability"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"dependencies:\n  built_collection: ^4.2.2\n  built_value: ^7.0.8\n  built_value_generator: ^7.0.8\n")),(0,r.kt)("p",null,"Functional programming and its immutable models as first class citizens are in trend now, and as Flutter incorporates many ideas of functional programming, it seems natural to go with immutable models \u2013 they really help a lot with tackling the complexity of your business logic."),(0,r.kt)("p",null,"Unfortunately, unlike let\u2019s say Kotlin data classes, Dart doesn\u2019t have immutable models out of the box. Luckily, we have libraries that take off some overhead in creating immutable objects: ",(0,r.kt)("inlineCode",{parentName:"p"},"built_collection")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"built_value"),"."),(0,r.kt)("p",null,"Let\u2019s see how we can use this library in our code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"abstract class Floor implements Built<Floor, FloorBuilder> {\n  factory Floor([Function(FloorBuilder b) updates]) =>\n      _$Floor((b) => b..update(updates));\n\n  Floor._();\n\n  String get floorNumber;\n\n  BuiltList<Space> get spaces;\n}\n")),(0,r.kt)("p",null,"Although it still seems to be rather verbose, some of this boilerplate can be managed by live templates, and we can focus on the main part of it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"abstract class Floor {\n  String get floorNumber;\n\n  BuiltList<Space> get spaces;\n}\n")),(0,r.kt)("p",null,"We\u2019re just defining an abstract class and a number of getters and the library will generate a code with all the functionality for let\u2019s say copying our object with partially changed properties. This is how it can be used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"final newFloor = floor.rebuild((b) => b..floorNumber = '1F');\n")),(0,r.kt)("p",null,"If you\u2019re familiar with Kotlin data classes, you can see some resemblance:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-kotlin"},'val newFloor = floor.copy(floorNumber = "1F")\n')),(0,r.kt)("p",null,"Actually this library gives us even more flexibility, because it implements a ",(0,r.kt)("inlineCode",{parentName:"p"},"Builder")," pattern under the hood that supports all the nested structure if you have a hierarchy of immutable objects and collections."),(0,r.kt)("h3",{id:"libraries-to-use-json"},"Libraries to use: JSON"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"dependencies:\n  json_annotation: ^3.0.1\n  json_serializable: ^3.2.5\n")),(0,r.kt)("p",null,"Another moment that will inevitably arise in any app that is dealing with API: serializing and deserializing JSON. Though the ",(0,r.kt)("inlineCode",{parentName:"p"},"built_value")," library can handle this as well, we found it rather verbose for that. Also DTOs are even more \u201cimmutable\u201d \u2013 if you need to partially copy DTO objects, then you\u2019re probably doing something wrong."),(0,r.kt)("p",null,"That\u2019s why for DTOs we actually use a more lightweight library: ",(0,r.kt)("inlineCode",{parentName:"p"},"json_serialization"),". It is also based on code generation principle and creates code for implementing ",(0,r.kt)("inlineCode",{parentName:"p"},"toJson")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"fromJson")," methods. This is how your DTO can look like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"@JsonSerializable()\nclass MessageDto {\n  MessageDto({this.id, this.createdUtc, this.text, this.creator});\n\n  final String id;\n  final String createdUtc;\n  final String text;\n  final MessageAuthorDto creator;\n\n  static MessageDto fromJson(Map<String, dynamic> json) =>\n      _$MessageDtoFromJson(json);\n\n  Map<String, dynamic> toJson() => _$MessageDtoToJson(this);\n}\n")),(0,r.kt)("p",null,"Again it can look a little verbose, but it can be solved with live templates as well. We can focus on the properties only, also in the majority of cases you need either ",(0,r.kt)("inlineCode",{parentName:"p"},"fromJson")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"toJson"),", but not both of them."),(0,r.kt)("p",null,"This is how it can be used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"final Response<Map<String, dynamic>> _result = await _dio.request(\u2026);\nfinal value = MessageDto.fromJson(_result.data);\n")),(0,r.kt)("p",null,"Actually, you won\u2019t probably write this code manually, as it can (and should) be generated by our next candidate."),(0,r.kt)("h3",{id:"libraries-to-use-api"},"Libraries to use: API"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"dependencies:\n  dio: ^3.0.7\n  retrofit: ^1.0.1+1\n  retrofit_generator: ^1.0.1+1\n")),(0,r.kt)("p",null,"If you have an experience in native Android development, I bet you know OkHttp and Retrofit libraries. Authors of these libraries know them for sure, and thanks to them we have ",(0,r.kt)("inlineCode",{parentName:"p"},"dio")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"retrofit")," libraries for Dart, which are working in a very similar way."),(0,r.kt)("p",null,"All you need to do in order to implement an API client, is to define an interface like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"@RestApi()\nabstract class RestClient {\n  factory RestClient(Dio dio) = _RestClient;\n\n  @POST('/api/general/v1/users/signOut')\n  Future<EmptyResponse> signOut(@Body() SignOutRequest request);\n}\n\n@JsonSerializable()\nclass EmptyResponse { \u2026 }\n\n@JsonSerializable()\nclass SignOutRequest { \u2026 }\n")),(0,r.kt)("p",null,"And the nice thing is that this library goes perfectly with the previous ",(0,r.kt)("inlineCode",{parentName:"p"},"json_serialization")," library, so your DTOs like ",(0,r.kt)("inlineCode",{parentName:"p"},"EmptyResponse")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"SignOutRequest")," here can be annotated with ",(0,r.kt)("inlineCode",{parentName:"p"},"@JsonSerializable")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"retrofit")," library will take care of proper serialization and deserialization."),(0,r.kt)("p",null,"So we can easily use this client, let\u2019s say, in our ",(0,r.kt)("inlineCode",{parentName:"p"},"AuthenticationManager")," that implements a higher level functionality:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"class AuthenticationManager {\n  AuthenticationManager(this._restClient);\n\n  final RestClient _restClient;\n\n  Future<Either<Exception, void>> logOut() =>\n      _restClient.signOut(SignOutRequest()).toEither();\n}\n")),(0,r.kt)("h3",{id:"libraries-to-use-di"},"Libraries to use: DI"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"dependencies:\n  provider: ^3.0.0+1\n")),(0,r.kt)("p",null,"And our last category of patterns that always comes out while aiming towards a clean architecture is dependency injection. There\u2019re several libraries to choose from for that, our choice is ",(0,r.kt)("inlineCode",{parentName:"p"},"provider"),". It\u2019s actually a mix of state management and dependency injection library, but we\u2019re using it for DI only."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"We've also experimented with ",(0,r.kt)("inlineCode",{parentName:"p"},"inject.dart")," \u2013 you can read about it here \u2013 but I wouldn't recommend it now, as it's not really FLutter way.")),(0,r.kt)("p",null,"As pretty much everything in Flutter is a widget, this library is not an exception. It\u2019s a wrapping widget that gives you the way to define value or factory providers and later retrieve them in the underlying widgets."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"@override\nWidget build(BuildContext context) => MultiProvider(\n      providers: [\n        Provider<RestClient>.value(value: _restClient),\n        Provider<MessagesRepository>.value(value: _messagesRepository),\n        Provider<ThreadDataLayer>.value(\n          value: ApiThreadDataLayer(\n            _restClient,\n            () => _imageUrlProvider.baseImageUrl().first,\n          ),\n        ),\n      ],\n      child: \u2026\n    );\n")),(0,r.kt)("p",null,"Let\u2019s say we have a ",(0,r.kt)("inlineCode",{parentName:"p"},"MessagesBloc")," that is dependent on ",(0,r.kt)("inlineCode",{parentName:"p"},"MessagesRepository")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"RestClient"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"class MessagesBloc {\n  MessagesBloc(\n    this._repository,\n    this._restClient,\n  );\n\n  final MessagesRepository _repository;\n  final RestClient _restClient;\n}\n")),(0,r.kt)("p",null,"Somewhere in the widget (let\u2019s say it\u2019s ",(0,r.kt)("inlineCode",{parentName:"p"},"MessagesScreen"),") we\u2019re creating our BLoC and pass the dependencies we\u2019ve retrieved from the provider:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"_messagesBloc = MessagesBloc(\n  Provider.of<MessagesRepository>(context),\n  Provider.of<RestClient>(context),\n);\n")),(0,r.kt)("p",null,"Yeah, it\u2019s sort of a so-called Poor Man\u2019s DI and we can go in a more complex way to eliminate the need for creating BLoC manually, but so far we are ok with this approach."),(0,r.kt)("p",null,"Actually, thanks to Dart\u2019s type inference system, that code can be made even shorter. As compiler knows what types are expected in constructor, we can omit generic types declarations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"_messagesBloc = MessagesBloc(Provider.of(context), Provider.of(context));\n")),(0,r.kt)("p",null,"Just keep in mind that this code can look rather confusing, so it\u2019s up to your team to decide whether you want to use this functionality."),(0,r.kt)("h2",{id:"architecture--structure-10000-foot-overview"},"Architecture / Structure: 10,000 foot overview"),(0,r.kt)("p",null,"Let\u2019s now talk about building an architecture and defining proper structure for your application. As this can actually be a theme of several other articles, I\u2019ll try to keep it really short and discuss only the general points."),(0,r.kt)("h3",{id:"structure"},"Structure"),(0,r.kt)("p",null,"Speaking of structure, there are 2 ways of organizing your code: ",(0,r.kt)("strong",{parentName:"p"},"horizontal")," and ",(0,r.kt)("strong",{parentName:"p"},"vertical"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Horizontal structure")," assumes that on your top level you have folders according to the functionality of classes inside: e.g. models, blocs and widgets:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\ud83d\udcc1 models\n  message.dart\n  thread.dart\n  profile.dart\n\ud83d\udcc1 blocs\n  messages_bloc.dart\n  profile_bloc.dart\n\ud83d\udcc1 widgets\n  messages_screen.dart\n  profile_screen.dart\n")),(0,r.kt)("p",null,"This can be tempting to structure your code like that in the very beginning, as it\u2019s easy to define which folder your file belongs to. The problem is that this structure becomes rather messy with the growth of your code base, and to change something in one module, let\u2019s say messages, you will have to go through multiple top-level folders."),(0,r.kt)("p",null,"That\u2019s why we prefer ",(0,r.kt)("strong",{parentName:"p"},"vertical structure"),", where your code is organized according to the use-case of the module. So on the top level we can have folders such as \u201cprofile\u201d, \u201cmessages\u201d etc. Inside these folders we can have nested sub-modules, extract shared models into a sub-folder or keep it as a flat list in a simple case:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\ud83d\udcc1 profile\n  profile.dart\n  profile_bloc.dart\n  profile_screen.dart\n\ud83d\udcc1 messages\n  \ud83d\udcc1 models\n    message.dart\n    thread.dart\n  messages_bloc.dart\n  messages_screen.dart\n")),(0,r.kt)("p",null,"Let\u2019s say in our app we have a \u201cmessages\u201d module. It means that we will have a top-level \u201cmessages\u201d folder. For threads screen we will use shared models, messages repository and screen-specific code will be located in the \u201cthreads\u201d folder."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"\ud83d\udcc1 messages\n  \ud83d\udcc1 create_thread\n    create_thread_bloc.dart\n    create_thread_screen.dart\n  \ud83d\udcc1 models\n    message.dart\n    message_author.dart\n    message_thread.dart\n  \ud83d\udcc1 thread_details\n    thread_details_screen.dart\n    thread_details_bloc.dart\n  \ud83d\udcc1 threads\n    threads_bloc.dart\n    threads_screen.dart\n    threads_tab.dart\n  messages_repository.dart\n")),(0,r.kt)("p",null,"When we go to a new thread screen, we\u2019re still using these models and messages repository, and screen specific code is located in the \u201ccreate_thread\u201d folder."),(0,r.kt)("h3",{id:"architecture"},"Architecture"),(0,r.kt)("p",null,"As Flutter is primarily a UI framework, it doesn\u2019t force you to use some specific architecture pattern, so you\u2019re free to use any of existing ones or invent your own. At the same time there\u2019s a pattern that\u2019s becoming a standard de facto in Flutter development: BLoC (Business Logic Component). The idea is rather simple and similar to redux pattern: you have a BLoC component that provides you an output stream of states and an input stream where you can send some events. BLoC transforms this incoming stream of events into an outcoming stream of new states. And the widget is supposed to consume a stream of states and send events."),(0,r.kt)("p",null,"We\u2019re using some mix between pure BLoC model and MVVM approach: our BL component defines a number of observable properties and exposes a set of methods that widget can use."),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("p",{parentName:"admonition"},"It's worth noting here that we've started developing our application in April 2019, when there was no unified opinion about building the architecture. As for now I would recommend going with ",(0,r.kt)("a",{parentName:"p",href:"https://bloclibrary.dev/"},"BLoC library")," which has a nice documentation and examples (I cannot say that it's now ",(0,r.kt)("strong",{parentName:"p"},"the only")," way to build your architecture, but BLoC approach in general, and this library in particular, is one of the most popular options). We're currently updating our app to use this library. Nevertheless, most of the points in this section make sense with this library as well.")),(0,r.kt)("p",null,"So in the center of it there is a view model that communicates with the widget. Widget knows only about its own view model. It listens to observable properties and builds UI of them, and uses methods of view model to send events. A view model in a simple case can change observable properties based on these events."),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(6485).Z,width:"1222",height:"862"})),(0,r.kt)("p",null,"In a more complex case view model can use some service (e.g. an API service) to retrieve some data. It sends a request and receives a response (it can be both synchronous and asynchronous request)."),(0,r.kt)("p",null,"Based on the response of the service, some of its observable properties can change and these changes will be propagated to the widget."),(0,r.kt)("p",null,"Another option for a view model is to \u201cfire and forget\u201d some request to a service. After this request is processed, service can update a repository, which exposes its state via stream as well. View model listens to this repository state and updates its data for the widget if necessary."),(0,r.kt)("p",null,"In this case the widget again receives an updated state. In any case widget knows only about its view model, view model knows about repositories and services and the latest ones know nothing about widgets and view models. That allows to build a cleaner architecture, where high levels don\u2019t depend on low levels."),(0,r.kt)("p",null,'Let\u2019s say we have a "create message thread" screen and there\u2019s an input field with the title of the thread. BLoC provides us a stream of strings with the current title value, so we connect to this stream on widget initialization and with each update force title controller to use the new value:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"class CreateThreadScreen extends StatefulWidget {\u2026}\n\nclass _CreateThreadScreenState extends State<CreateThreadScreen> {\n  @override\n  void afterInitState() {\n    super.afterInitState();\n\n    bloc.title\n        .map((v) => _titleController.value.copyWith(text: v))\n        .listen((v) => _titleController.value = v, onError: ignore)\n        .addTo(_subscriptions);\n  }\n}\n")),(0,r.kt)("p",null,"In that case our BLoC can contain such a code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"class CreateThreadBloc extends BlocBase {\n  /// Title of the conversation\n  Stream<String> get title => _title.transform(emptyValidationTransformer);\n  final BehaviorSubject<String> _title = BehaviorSubject.seeded('');\n\n  /// Creates new message thread or updates existing one.\n  Future<Either<Exception, MessageThread>> submit() async {\n    Either<Exception, MessageThread> result;\n    if (initialThread == null) {\n      result = await _createThread();\n    } else {\n      result = await _updateThread();\n    }\n    return result;\n  }\n}\n")),(0,r.kt)("p",null,"For the title stream we are actually using behavior subject under the hood, but we expose only a stream, so that client (widget) cannot change it directly, only through a predefined interface."),(0,r.kt)("p",null,"And let\u2019s say we need some method to submit a thread to the server. It can be either creating a new thread or updating an existing one."),(0,r.kt)("p",null,"Creating a new thread can look like this \u2013 we prepare some data and call a method from data layer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"Future<Either<Exception, MessageThread>> _createThread() async {\n    final selectedEmployees =\n      _selectedEmployees.value.map((employee) => employee.id).toList();\n\n    return data.createNewThread(_title.value, selectedEmployees).map((thread) {\n      repository.saveThread(thread);\n      return thread;\n    });\n  }\n")),(0,r.kt)("p",null,"Data layer provides another abstraction layer of the REST client. Since communication with a server is an infrastructure task, our business layer shouldn\u2019t depend on it, also we would be able to unit test the business layer without providing or mocking REST clients."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"abstract class ThreadDataLayer {\n  Future<Either<Exception, MessageThread>> createNewThread(\n    String subject,\n    List<String> employeeIds,\n  );\n}\n")),(0,r.kt)("p",null,"That means we can define an interface \u2013 actually, an abstract class since Dart doesn\u2019t have an interface keyword \u2013 that will abstract over thread creating."),(0,r.kt)("p",null,"This interface can be placed into the module with the view model itself, since it\u2019s just an abstract dependency for our business logic. We can easily implement a stub class for our unit tests. For a real application we need real communication, so we can create an ",(0,r.kt)("inlineCode",{parentName:"p"},"ApiThreadDataLayer")," that depends on ",(0,r.kt)("inlineCode",{parentName:"p"},"RestClient")," and does real API calls. As this is an implementation detail, we can place this class somewhere in the infrastructure level:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"class ApiThreadDataLayer implements ThreadDataLayer {\n  final RestClient _restClient;\n\n  @override\n  Future<Either<Exception, MessageThread>> createNewThread(\u2026) async {\u2026}\n}\n")),(0,r.kt)("p",null,"These are the most important libraries that we\u2019re using almost for each Flutter project. Of course there are tons of them implementing UI widgets, native plugins and so on, making a detailed review is out of the scope for this presentation, so let\u2019s continue with other tips that can be useful for a production-ready app."),(0,r.kt)("h2",{id:"other-tips-tldr-do-it-well"},"Other tips. TLDR: do it well"),(0,r.kt)("h3",{id:"code-style"},"Code style"),(0,r.kt)("p",null,"Code formatting can be a very arguable topic. But as they say in the army: there are 2 opinions \u2013 one is mine, another is wrong. This is the position of a built in dart formatter: there is only one right way to format your code."),(0,r.kt)("p",null,"And if you accept this position you can actually make your collaboration and code reviewing easier, like we did by setting up CI server. If any of the files in PR is not formatted correctly from the dartfmt point of view, the build will fail and you cannot merge it into master branch."),(0,r.kt)("p",null,"This code, for example, looks ok to me:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"class SharedPrefTokenRepository implements TokenRepository {\n  @override\n  Future<void> save(String token) async =>\n      (await SharedPreferences.getInstance())\n          .setString(_keyToken, token);\n\n  @override\n  Future<String> load() async => (await SharedPreferences.getInstance())\n      .getString(_keyToken);\n\n  static const String _keyToken = 'token';\n}\n")),(0,r.kt)("p",null,"But ",(0,r.kt)("inlineCode",{parentName:"p"},"dartfmt")," says that it should be formatted in a different way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"class SharedPrefTokenRepository implements TokenRepository {\n  @override\n  Future<void> save(String token) async =>\n      (await SharedPreferences.getInstance()).setString(_keyToken, token);\n\n  @override\n  Future<String> load() async =>\n      (await SharedPreferences.getInstance()).getString(_keyToken);\n\n  static const String _keyToken = 'token';\n}\n")),(0,r.kt)("h3",{id:"static-analysis"},"Static analysis"),(0,r.kt)("p",null,"Another moment that can greatly help you with catching hidden bugs and unifying code style is static analysis, and luckily we have a built in analyzer as well. Though by default it\u2019s too kind, as for me. That\u2019s why we went through most of its rules and defined our own importance levels for them."),(0,r.kt)("p",null,"Some of them we defined as warning, it means that IDE will mark them with yellow color, but, unlike errors, warnings won\u2019t prevent you from running and hot reloading your app. That\u2019s very convenient, because things like not closed sinks or empty statements can happen while you\u2019re experimenting with your code and you don\u2019t usually want to waste your time to prettify your churn code."),(0,r.kt)("p",null,"At the same time CI server runs analysis as well, and will fail the build if it contains errors or warnings, so before requesting a code review you will need to take care of them."),(0,r.kt)("h3",{id:"extract-widgets"},"Extract widgets"),(0,r.kt)("p",null,"When you start developing with Flutter, you can often come to a situation with a bloated build method that contains a lot of nesting:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"@override\nWidget build(BuildContext context) => Scaffold(\n      body: SingleChildScrollView(\n        child: Padding(\n          padding: const EdgeInsets.symmetric(horizontal: 16),\n          child: Column(\n            children: <Widget>[\n              Padding(\n                padding: const EdgeInsets.only(top: 145, bottom: 102),\n                child: SvgPicture.asset(\n                  'assets/mews_logo.svg',\n                  height: 28,\n                  width: 136,\n                ),\n              ),\n              StreamBuilder<String>(\n                stream: bloc.email,\n                builder: (context, snapshot) => MewsInputField(\n                  textInputAction: TextInputAction.next,\n                  onSubmitted: (_) {\n                    FocusScope.of(context).requestFocus(_passwordFocus);\n                  },\n                  label: _translate(TranslationKey.UserNameOrEmail),\n                  placeholder: _translate(TranslationKey.UserNameOrEmail),\n                  onChanged: bloc.onEmailChanged,\n                  keyboardType: TextInputType.emailAddress,\n                  error: (snapshot.error as ValidationError)?.message,\n                  isRequired: true,\n                ),\n              ),\n              Padding(\n                padding: const EdgeInsets.only(top: 24),\n                child: StreamBuilder<String>(\n                  stream: bloc.password,\n                  builder: (context, snapshot) => MewsInputField(\n                    enableInteractiveSelection: true,\n                    textInputAction: TextInputAction.go,\n                    onSubmitted: (_) => _logIn(),\n                    focusNode: _passwordFocus,\n                    isPasswordField: true,\n                    label: _translate(TranslationKey.Password),\n                    placeholder: _translate(TranslationKey.Password),\n                    onChanged: bloc.onPasswordChanged,\n                    error: (snapshot.error as ValidationError)?.message,\n                    isRequired: true,\n                  ),\n                ),\n              ),\n              Padding(\n                padding: const EdgeInsets.only(top: 40),\n                child: MewsFillButton(\n                  minWidth: double.infinity,\n                  onPressed: _logIn,\n                  text: _translate(TranslationKey.SignIn),\n                ),\n              ),\n              Padding(\n                padding: const EdgeInsets.only(top: 16),\n                child: StreamBuilder<Environment>(\n                  stream: _environmentBloc.environment,\n                  initialData: Environment.production,\n                  builder: (context, snapshot) => MewsGhostButton(\n                    minWidth: double.infinity,\n                    text: 'Environment: ${snapshot.data.name}',\n                    onPressed: _displayChangeEnvironmentDialog,\n                  ),\n                ),\n              )\n            ],\n          ),\n        ),\n      ),\n    );\n")),(0,r.kt)("p",null,"So when it comes to building a layout, main advice is to keep your build method flat and readable. For example with a minimum effort this code can look much better:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"@override\nWidget build(BuildContext context) => Scaffold(\n      body: SingleChildScrollView(\n        child: Padding(\n          padding: const EdgeInsets.symmetric(horizontal: 16),\n          child: Column(\n            children: <Widget>[\n              const _Logo(),\n              _buildEmailField(),\n              _buildPasswordField(),\n              _buildSubmitButton(),\n              _buildChangeEnvironmentButton()\n            ],\n          ),\n        ),\n      ),\n    );\n")),(0,r.kt)("p",null,"One option is to extract some part of your code into a separate widget. And if it doesn\u2019t depend on properties of your parent widget you can even declare it a constant and gain a performance improvement."),(0,r.kt)("p",null,"If it\u2019s not possible or doesn\u2019t seem to be reasonable you can at least define some helper build methods that will improve readability."),(0,r.kt)("h3",{id:"logging"},"Logging"),(0,r.kt)("p",null,"When we\u2019ve rewritten our app with Flutter, we\u2019ve got this picture in Crashlytics:"),(0,r.kt)("p",null,(0,r.kt)("img",{src:a(7483).Z,width:"448",height:"302"})),(0,r.kt)("p",null,"This doesn\u2019t mean of course, that we\u2019ve become perfect developers or that Flutter doesn\u2019t allow you to make any error in your code. It\u2019s about the way Flutter works: it\u2019s actually very hard to make Flutter app crash. It can crash if there\u2019s an error in native plugin or in native part of Flutter itself, but errors in your Dart code will trigger a red screen of death in debug mode, and be swallowed in production."),(0,r.kt)("p",null,"It can be both an advantage and a drawback: yes, users won\u2019t probably see your app crashing, but at the same time if you have an error while displaying a modal loader dialog, a user has a chance to be stuck at this screen forever."),(0,r.kt)("p",null,"That\u2019s why for a production app it\u2019s crucial to have a proper logging system. For our project we\u2019re using the same stack as other platforms in Mews: Sentry for error reporting and InsightOps for all the logging. You can set up your Flutter app to use these systems pretty easily."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-yaml"},"dependencies:\n  logging: ^0.11.3+2\n  sentry: ^2.2.0\n  insightops_dart: ^0.0.6\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-dart"},"await runZoned<Future<void>>(\n  () async => runApp(app),\n  onError: _reportError,\n);\n\nFlutterError.onError = (FlutterErrorDetails details) {\n  Zone.current.handleUncaughtError(details.exception, details.stack);\n};\n")),(0,r.kt)("p",null,"That\u2019s it! Of course, each of these sections can be discussed in a separate article (or even a book), so if you\u2019re interested we can continue with this how-to series and share our experience in creating cross-platform apps that can be even better than native ones."))}u.isMDXComponent=!0},6485:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/architecture-2e008c784799e6c0cd137ad3269cf2fa.png"},5339:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/commander-981c862acd7f37d37b2793b6efda297c.png"},7483:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/crashlytics-56de3e3fed1d39b7048e3f59c02aeaba.png"}}]);