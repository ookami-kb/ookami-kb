"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[2468],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>p});var n=a(7294);function o(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){o(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function s(e,t){if(null==e)return{};var a,n,o=function(e,t){if(null==e)return{};var a,n,o={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(o[a]=e[a]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(o[a]=e[a])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=c(a),p=o,m=h["".concat(l,".").concat(p)]||h[p]||d[p]||i;return a?n.createElement(m,r(r({ref:t},u),{},{components:a})):n.createElement(m,r({ref:t},u))}));function p(e,t){var a=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=a.length,r=new Array(i);r[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,r[1]=s;for(var c=2;c<i;c++)r[c]=a[c];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},9924:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var n=a(7462),o=(a(7294),a(3905));const i={},r='"Clean" Architecture vs pragmatic architecture',s={permalink:"/ru/blog/2023/02/14/clean-architecture-vs-pragmatic-architecture",source:"@site/blog/2023-02-14-clean-architecture-vs-pragmatic-architecture/index.md",title:'"Clean" Architecture vs pragmatic architecture',description:"This article is based on a meetup talk I gave in January 2023.",date:"2023-02-14T00:00:00.000Z",formattedDate:"14 \u0444\u0435\u0432\u0440\u0430\u043b\u044f 2023 \u0433.",tags:[],readingTime:18.3,hasTruncateMarker:!0,authors:[],frontMatter:{},nextItem:{title:"Working with NFC in Flutter",permalink:"/ru/blog/2022/09/02/flutter-nfc"}},l={authorsImageUrls:[]},c=[{value:"Problems",id:"problems",level:2},{value:"Pragmatic approach",id:"pragmatic-approach",level:2},{value:"Example",id:"example",level:2},{value:"Favorites module",id:"favorites-module",level:3},{value:"Popular movies module",id:"popular-movies-module",level:3},{value:"Outcomes",id:"outcomes",level:2}],u={toc:c};function d(e){let{components:t,...i}=e;return(0,o.kt)("wrapper",(0,n.Z)({},u,i,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"This article is based on a ",(0,o.kt)("a",{parentName:"p",href:"https://www.youtube.com/embed/ltwhgPFPcLc"},"meetup talk")," I gave in January 2023."),(0,o.kt)("p",null,"I'm working as a Staff Mobile Engineer at Mews. What staff engineers usually do differs from company to company and even department to department. In my case, it means that I do not belong to any specific team, but rather, I help other teams on an ad hoc basis with things like code reviewing, mentoring, discussing architecture, and solutioning."),(0,o.kt)("p",null,"Besides this, I do some external mentoring and consulting, and of course, one of the most popular topics we discuss is app architecture. Since Clean Architecture is one of the most popular for apps in general and mobile and Flutter apps in particular, we discuss a lot of questions like what it is, how to do it better, and how to go about app architecture from the Clean Architecture point of view."),(0,o.kt)("p",null,"Here, I will be discussing Clean Architecture as well. The word \"clean\" in the title isn't in quotation marks because I see Clean Architecture as the opposite of pragmatic or vice versa. It's just that I often see many implementations of Clean Architecture in different tutorials and real-life projects that, from my point of view, don't follow its core principles. At the same time, there are some issues with the architecture itself. I believe it's not always a perfect fit for Flutter apps, so let's start with these issues."),(0,o.kt)("h2",{id:"problems"},"Problems"),(0,o.kt)("p",null,"First of all, Clean Architecture was created with a different environment in mind. Robert Martin speaks about the whole software system in general, so concerning the web application, it will be both backend and frontend under these Clean Architecture rules. Many of the things discussed there are considered to be implementation details. UI, deployments \u2013 Robert Martin speaks of them as implementation details that good architecture should not ignore but rather postpone associated decisions until the very last moment. But when it comes to Flutter app architecture, a lot of these things are already fixed: we have a fixed platform \u2013 it's mobile, a fixed language \u2013 Dart, even the framework, Flutter, is fixed."),(0,o.kt)("p",null,"Of course, it affects our architectural decisions, and it allows us to make the architecture simpler: we don't need to introduce some abstractions because, for example, we are not going to swap Flutter with some other framework \u2013 it would be a completely different app. Also, Robert Martin pays a lot of attention to things like separating deployments, which again, in the case of the Flutter app, don't make sense: we cannot have microservices in the mobile app and deploy them separately. In general, Clean Architecture is very defensive: it introduces a lot of abstractions which, as Robert Martin says, are not always needed, but it can be challenging to implement Clean Architecture for Flutter apps fully and properly."),(0,o.kt)("p",null,"But, as I said, my main complaints are about the implementation. I often see tutorial authors proposing to structure the application by layers. What do I mean by that? Check what's probably the most popular image you can find when googling Clean Architecture:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"The Clean Architecture",src:a(6478).Z,width:"772",height:"567"})),(0,o.kt)("p",null,"It's the division of layers where you have entities with business rules on top, then use cases, controllers, presenters, and so on. And many developers take this picture as their guide for the folders structure:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-txt"},"> app\n    > pages\n    > widgets\n    > utils\n> data\n    > repositories\n    > helpers\n> domain\n    > entities\n    > usecases\n")),(0,o.kt)("p",null,"The problem with this approach is that it's not scalable. When your app grows larger, you see that these three or four layers are not enough. You need to modularize your app further, anyway."),(0,o.kt)("p",null,"It's also not properly encapsulated: if you want your presenter layer to use something from the use cases or models (from the domain layer), you need to make these use cases or models public. But that means that any other part of the app can use them as well and, for example, the authentication presentation module can import models or use cases from the favorites module domain layer. This is not what we usually want."),(0,o.kt)("p",null,"Also, this architecture doesn't scream enough. As Robert Martin says, architecture should scream about its intentions, about what it is used for."),(0,o.kt)("p",null,"I hope that you all agree that the structure on the right gives us a lot more information about what the app is doing:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-txt"},"> app                               > app\n    > pages                             > screens\n    > widgets                       > features\n    > utils                             > auth\n> data                                  > movie_details\n    > repositories                      > favorite_movies\n    > helpers                           > popular_movies\n> domain                                > search\n    > entities\n    > usecases\n")),(0,o.kt)("p",null,"On the left, we see the common structure, so if we take two apps from totally separate domains, they will look exactly the same: there will be pages, repositories, use cases, and so on. At the same time, on the right, it's clearly visible: okay, obviously the app has something to do with movies, we have some search functionality, and we can mark some movies as favorites. It's screaming that this is a movie app."),(0,o.kt)("p",null,"Another pretty big problem is that these authors take into consideration only one part of the slicing: I mentioned slicing by layers, but we also have slicing by features, and it's much more important. In a large app, you can have hundreds of different features as opposed to three or four different layers. How these features communicate with each other and how they depend on each other is much more significant. Not taking this into account can quickly turn your architecture into a mess."),(0,o.kt)("p",null,"Finally, the authors try to build the framework and say that this will be the universal framework to fit any app, but this is impossible. Clean architecture is not about the framework but about guides and rules on how to build the architecture. As Robert Martin says:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"The component structure cannot be designed from the top down. It is not one of the first things about the system that is designed, but rather evolves as the system grows and changes.")),(0,o.kt)("p",null,"For me, this is the quintessence of this framework-minded approach:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-txt"},"lib/\n    app/                          <--- application layer\n        pages/                        <-- pages or screens\n          login/                        <-- some page in the app\n            login_controller.dart         <-- login controller extends Controller\n            login_presenter.dart          <-- login presenter extends Presenter\n            login_view.dart               <-- login view, 2 classes extend View and ViewState resp.\n        widgets/                      <-- custom widgets\n        utils/                        <-- utility functions/classes/constants\n        navigator.dart                <-- optional application navigator\n    data/                         <--- data layer\n        repositories/                 <-- repositories (retrieve data, heavy processing etc..)\n          data_auth_repo.dart           <-- example repo: handles all authentication\n        helpers/                      <-- any helpers e.g. http helper\n        constants.dart                <-- constants such as API keys, routes, urls, etc..\n    device/                       <--- device layer\n        repositories/                 <--- repositories that communicate with the platform e.g. GPS\n        utils/                        <--- any utility classes/functions\n    domain/                       <--- domain layer (business and enterprise) PURE DART\n        entities/                   <--- enterprise entities (core classes of the app)\n          user.dart                   <-- example entity\n          manager.dart                <-- example entity\n        usecases/                   <--- business processes e.g. Login, Logout, GetUser, etc..\n          login_usecase.dart          <-- example usecase extends UseCase or CompletableUseCase\n        repositories/               <--- abstract classes that define functionality for data and device layers\n    main.dart                     <--- entry point\n")),(0,o.kt)("p",null,"I found this package on ",(0,o.kt)("inlineCode",{parentName:"p"},"pub.dev"),". The author tries to build the framework out of Clean Architecture and introduces a lot of abstractions like ",(0,o.kt)("inlineCode",{parentName:"p"},"\u0421ontroller"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"Presenter"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"View"),", ",(0,o.kt)("inlineCode",{parentName:"p"},"ViewState")," \u2013 and this is all just for the UI layer, there are tons of other abstract classes and interfaces as well. For me, this architecture looks messy: to find something meaningful there, to find that there are some classes like ",(0,o.kt)("inlineCode",{parentName:"p"},"UserManager")," or ",(0,o.kt)("inlineCode",{parentName:"p"},"LoginUseCase"),", you have to go deep down into the folder structure. Even from the point of maintainability, if you need to change something in the login flow, you'll most likely go through multiple folders across the whole repository."),(0,o.kt)("h2",{id:"pragmatic-approach"},"Pragmatic approach"),(0,o.kt)("p",null,"If we talk about a pragmatic approach to architecture in general, and to Clean Architecture in particular, we need to start with some core principles that lay the foundation of this Clean Architecture."),(0,o.kt)("p",null,"For me, the first principle is the principle of ",(0,o.kt)("strong",{parentName:"p"},"acyclic dependencies"),'. Your dependencies should form a directed acyclic graph. If we take a look at the definition of a directed acyclic graph on Wikipedia, it says that a "directed acyclic graph is a directed graph with no directed cycles". Very correct yet totally useless definition, right?'),(0,o.kt)("p",null,"For our use case, it just means that we have a representation of our modules and the dependencies between them:"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Directed Acyclic Graph",src:a(9108).Z,width:"1280",height:"1757"})),(0,o.kt)("p",null,"If we have an arrow from module A to module B, it means module A depends on module B. And being acyclic means that we can take any module, let's say module B, and follow the direction of each arrow (e.g. from C to D and then to E, or from C to E directly), and there would be no way to go back to module B again."),(0,o.kt)("p",null,"Why is it important? First of all, having cycles turns modules within a cycle into one big module: if you have module A depending on module B and module B depending back on module A, it means that you have one big module \u2013 you cannot use these modules separately, you cannot test them separately, so it will be just one big module AB."),(0,o.kt)("p",null,"Another issue is that for architecture to be understandable and maintainable you want to distinguish between stable and non-stable components. For example, component E here is very stable \u2013 it doesn't depend on anything else, so for it, the only reason to change is if the requirements for the module itself are changing. At the same time, module A is very non-stable because it depends on every other component in the system. It means that if any other component changes, there is a high chance that module A will require some changes as well. At least, it's good to understand what components in your system are stable and non-stable, and at the same time, if you have a module that you know will be non-stable, that you know will change a lot (e.g. its requirements are not finalized yet), it's better to separate it from stable modules. Also, stable components should not depend on non-stable components, otherwise, they would become non-stable as well."),(0,o.kt)("p",null,"Another principle is ",(0,o.kt)("strong",{parentName:"p"},"structuring by components"),". As Robert Martin says:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"For most applications, maintainability is more important than reusability. If the code in an application must change, you would rather that all of the changes occur in one component, rather than being distributed across many components.")),(0,o.kt)("p",null,"By component here, I mean what Simon Brown defines in the same book, ",(0,o.kt)("em",{parentName:"p"},"The Clean Architecture"),":"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"A grouping of related functionality behind a nice clean interface, which resides inside an execution environment like an application.")),(0,o.kt)("p",null,"The third principle is the principle of reasonable abstractions: every abstraction adds complexity to the app, so don't add abstractions that do nothing useful. Robert Martin says the same about boundaries:"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Your goal is to implement the boundaries right at the inflection point where the cost of implementing becomes less than the cost of ignoring.")),(0,o.kt)("p",null,"Again, one of the examples that I found:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-dart"},"class GetConcreteNumberTrivia implements UseCase<NumberTrivia, Params> {\n  final NumberTriviaRepository repository;\n\n  GetConcreteNumberTrivia(this.repository);\n\n  @override\n  Future<Either<Failure, NumberTrivia>> call(Params params) async {\n    return await repository.getConcreteNumberTrivia(params.number);\n  }\n}\n\nclass Params extends Equatable {\n  final int number;\n\n  Params({@required this.number});\n\n  @override\n  List<Object> get props => [number];\n}\n")),(0,o.kt)("p",null,"It's a pretty popular tutorial on how to build Clean Architecture and clean code in general. For me, it's bad on many levels simultaneously. First of all, it just screams \"Java 6\" with all these abstract classes, generic parameters, and interfaces. Even on the code level, it can be simplified, but the main problem here is that this class pretends that there is logic behind it. But there is no logic \u2013 all this class does is just proxying the call to the repository method, which even has the same name ",(0,o.kt)("inlineCode",{parentName:"p"},"getConcreteNumberTrivia"),", and that means that we just add complexity here. We make the whole solution more complex, but we do not hide anything. For the client, it would be simpler to just call the repository method directly."),(0,o.kt)("p",null,"What are the outcomes? First, Clean Architecture doesn't enforce a structure. It's not a framework, it just provides the rules and guides on how you want to abstract something and how you want to form your dependencies so that they don't form cycles. Start with a really simple structure. Your goal is not to create correct architecture from the very beginning, your goal is to make it easy to change when the requirements change. Remember that architecture evolves with the project because architecture is the project. It's about how your components work together and depend on each other. As simple yet powerful advice, keep an eye on your dependencies diagram because it can serve as a litmus test that can quickly show you if you're going in the wrong direction if your architecture is becoming more complex and messy."),(0,o.kt)("p",null,'But of course, the main advice is: "Think!" There is no silver bullet or universal framework that can fit any app.'),(0,o.kt)("h2",{id:"example"},"Example"),(0,o.kt)("p",null,"As a quick example, we can take a look at my ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ookami-kb/my_tmdb"},"sample project"),". It is a very simple client for TheMovieDatabase API: it provides functionality such as authenticating, adding movies to favorites, searching for movies, and so on. We can see that even for such a small application, the dependency graph can look messy and big:"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://github.com/ookami-kb/my_tmdb/raw/main/deps.png",alt:"Dependencies"})),(0,o.kt)("p",null,"But no worries! We don't need to work with this graph daily."),(0,o.kt)("p",null,"For now, we just need a couple of things from this graph. First, we can make sure that it's acyclic, and second, it can give us the overall picture of different modules and the dependencies between them. Since the whole graph is acyclic, we can take one module and look at it separately, and the dependencies in the module will also be acyclic. Inside this module, we can see the layered structure of the presentation, use cases, models, and so on."),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Overall structure",src:a(9167).Z,width:"1720",height:"1760"})),(0,o.kt)("p",null,"If we take a look at the overall structure, we can see that there is a top-level ",(0,o.kt)("inlineCode",{parentName:"p"},"app")," folder with some glue code, routes, and entry points, and a ",(0,o.kt)("inlineCode",{parentName:"p"},"core")," folder with some shared functionality that is not connected to any specific feature. The main part of the app is the ",(0,o.kt)("inlineCode",{parentName:"p"},"features")," folder, where we can find components that are more or less independent from each other, and that provide some related functionality behind an interface. This is exactly the definition of the component by Simon Brown."),(0,o.kt)("h3",{id:"favorites-module"},"Favorites module"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Favorites module structure",src:a(8088).Z,width:"1720",height:"1132"})),(0,o.kt)("p",null,"If you take a deeper look into some of the modules, let's say the favorites module, we can see that there is an ",(0,o.kt)("inlineCode",{parentName:"p"},"src")," folder. It's kind of a hack because currently, Dart doesn't provide a way to define a properly established module with a separated internal structure and public interfaces. We can just pretend that everything in the ",(0,o.kt)("inlineCode",{parentName:"p"},"src")," folder is internal and should not be used from outside the module. We can even set up a linter so that it will give you an error if you try to import something from the ",(0,o.kt)("inlineCode",{parentName:"p"},"src")," folder from outside of this module folder."),(0,o.kt)("p",null,"Inside the ",(0,o.kt)("inlineCode",{parentName:"p"},"src")," folder, we have an API client and repository, which both provide data from the backend. We have a BLoC that encapsulates some UI-agnostic application logic: this is not a ViewModel from the MVVM pattern, but rather an implementation of a use case from Clean Architecture. Next, we have widgets that are the only public entity in this module: any client who wants to use this module can only do it through this widget. The Widget is not the View from MVVM, it can hold some UI-related logic inside."),(0,o.kt)("p",null,"Speaking of the difference between the API client and repository: the API client should be as close as possible to the real API structure on the backend. It doesn't have any app logic, it just provides the methods that are closely mapped to the backend API structure, and it converts requests and responses from JSON to Dart classes and back:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-dart"},"@RestApi()\nabstract class FavoritesApiClient {\n  factory FavoritesApiClient(\n    Dio dio, {\n    required String baseUrl,\n  }) = _FavoritesApiClient;\n\n  @POST('/account/{account_id}/favorite')\n  Future<void> markAsFavorite({\n    @Path('account_id') required int accountId,\n    @Query('api_key') required String apiKey,\n    @Query('session_id') required String sessionId,\n    @Body() required MarkAsFavoriteRequestDto body,\n  });\n\n  @GET('/movie/{movie_id}/account_states')\n  Future<MovieAccountStatesResponseDto> getMovieAccountStates({\n    @Path('movie_id') required int movieId,\n    @Query('api_key') required String apiKey,\n    @Query('session_id') required String sessionId,\n  });\n\n  @GET('/tv/{tv_id}/account_states')\n  Future<TvAccountStatesResponseDto> getTvAccountStates({\n    @Path('tv_id') required int tvId,\n    @Query('api_key') required String apiKey,\n    @Query('session_id') required String sessionId,\n  });\n}\n")),(0,o.kt)("p",null,"The repository is the entity that provides methods convenient for the app itself and that are meaningful from the app logic point of view. It can, for example, hide some non-related complexity, like the fact that we need to provide an API key with every request. Or it can compose several different method calls to the API, process them somehow, and turn them into models that, yet again, make sense to the app logic (mainly to the BLoC, as it's the primary consumer of the repository):"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-dart"},"class FavoritesRepository {\n  FavoritesRepository({\n    required FavoritesApiClient api,\n    required String apiKey,\n  })  : _apiKey = apiKey,\n        _api = api;\n\n  final FavoritesApiClient _api;\n  final String _apiKey;\n\n  AsyncResult<void> addToFavorites({\n    required ContentId id,\n    required Authenticated info,\n  }) =>\n      _api\n          .markAsFavorite(\n            accountId: info.accountId,\n            apiKey: _apiKey,\n            sessionId: info.sessionId,\n            body: MarkAsFavoriteRequestDto(\n              mediaType: id.type.toDto(),\n              mediaId: id.value,\n              favorite: true,\n            ),\n          )\n          .toEither();\n\n  // ...\n}\n")),(0,o.kt)("p",null,"BLoC, in turn, encapsulates the app logic. It can use repository methods and add some functionality on top of them. It emits a set of app states, e.g. the app is busy doing something, or we have an error while processing the user input, or we succeeded in making a request:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-dart"},"Future<void> _handleAddToFavorites(\n  AddToFavorites event,\n  _Emitter emit,\n) async {\n  emit(const FavoritesState.processing());\n\n  final newState = await _repository\n      .addToFavorites(id: _contentId, info: event.info)\n      .foldAsync(\n        (_) => const FavoritesState.failure(),\n        (_) => const FavoritesState.fetched(isFavorite: true),\n      );\n  emit(newState);\n}\n")),(0,o.kt)("p",null,"The widget usually uses the BLoC, and it can act as a simple proxy that takes the user input and sends events to the block, e.g. a user presses the button and the widget decides to send an event for adding the movie to favorites, or for removing it from favorites. The widget also renders the interface \u2013 it can decide whether the button should be enabled or disabled and whether we should display a progress bar:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-dart"},"BlocBuilder<FavoritesBloc, FavoritesState>(\n  builder: (context, state) => state.maybeMap(\n    fetched: (state) => FloatingActionButton(\n      onPressed: () => context.read<FavoritesBloc>().add(\n            state.isFavorite\n                ? FavoritesEvent.removeFromFavorites(info: info)\n                : FavoritesEvent.addToFavorites(info: info),\n          ),\n      child: state.isFavorite ? favoriteIcon : nonFavoriteIcon,\n    ),\n    orElse: () => const FloatingActionButton(\n      onPressed: null,\n      child: nonFavoriteIcon,\n    ),\n  ),\n);\n")),(0,o.kt)("p",null,"But it can also act as the manager of some UI logic. For example, if we know that to add a movie to favorites, we need to provide some authentication info, then the widget can try to get this info. If it's not available (meaning the user is not authenticated), then it shows the authentication dialog (showing a dialog is pure UI logic). If the authentication was successful and we got the credentials, the widget can send the corresponding event to the BLoC with all the required data:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-dart"},"if (info is! Authenticated) {\n  return FloatingActionButton(\n    onPressed: () async {\n      final info = await AuthDialog.show(context);\n      if (info == null || !mounted) return;\n\n      context\n          .read<FavoritesBloc>()\n          .add(FavoritesEvent.addToFavorites(info: info));\n    },\n    child: nonFavoriteIcon,\n  );\n}\n")),(0,o.kt)("h3",{id:"popular-movies-module"},"Popular movies module"),(0,o.kt)("p",null,(0,o.kt)("img",{alt:"Popular movies module structure",src:a(3802).Z,width:"1712",height:"1408"})),(0,o.kt)("p",null,"If we take a look at another module, we can see that the structure is flexible and there are no useless abstractions. We have no BLoC here because we don't have any app logic \u2013 the widget just calls the repository directly."),(0,o.kt)("p",null,"For example, if all you need is just fetching some data, displaying the progress bar while the data are being fetched, and then either showing an error message or displaying the successful result, it's just work for ",(0,o.kt)("inlineCode",{parentName:"p"},"FutureBuilder"),". We just need to provide the future there (it can be initiated by getting the repository from the service locator and calling the corresponding method right in the ",(0,o.kt)("inlineCode",{parentName:"p"},"initState")," method). That's it \u2013 there is no more logic there:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-dart"},"class _PopularMoviesWidgetState extends State<PopularMoviesWidget> {\n  late final AsyncResult<IList<PopularMovie>> _result;\n\n  @override\n  void initState() {\n    super.initState();\n\n    _result = sl<PopularMoviesRepository>().fetchPopularMovies();\n  }\n\n  @override\n  Widget build(BuildContext context) => SingleChildScrollView(\n        child: Column(\n          crossAxisAlignment: CrossAxisAlignment.start,\n          children: [\n            Padding(\n              padding: const EdgeInsets.all(12),\n              child: Text(\n                'Popular Movies',\n                style: Theme.of(context).textTheme.headline4,\n              ),\n            ),\n            SizedBox(\n              height: 304,\n              child: FutureBuilder(\n                future: _result,\n                builder: (context, snapshot) {\n                  final data = snapshot.data;\n                  if (data == null) {\n                    return const Center(child: CircularProgressIndicator());\n                  }\n\n                  return data.fold(\n                    (_) => const Center(child: Text('Something went wrong.')),\n                    (movies) => PopularMoviesList(\n                      movies: movies,\n                      onItemPressed: widget.onItemPressed,\n                    ),\n                  );\n                },\n              ),\n            ),\n          ],\n        ),\n      );\n}\n")),(0,o.kt)("h2",{id:"outcomes"},"Outcomes"),(0,o.kt)("p",null,"Coming back to the outcomes:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Architecture doesn't enforce a structure, but I usually recommend organizing folders and grouping them by components. These components do not necessarily reflect the app hierarchy. For example, the ",(0,o.kt)("inlineCode",{parentName:"li"},"FavoriteButton")," widget can be located in the movie details, it can be on the search results screen, but still, it will sit in the top-level feature folder because this is a separate module that provides some piece of functionality and is responsible for it. It can be used anywhere in the app."),(0,o.kt)("li",{parentName:"ul"},"Start with a simple structure. It's easier to add abstractions than to remove them."),(0,o.kt)("li",{parentName:"ul"},"Remember that the architecture evolves with the project, so don't try to foresee the future. Remember the YAGNI principle."),(0,o.kt)("li",{parentName:"ul"},"Keep an eye on your dependencies diagram, probably by using some automated tools. For example, in this repository, I use ",(0,o.kt)("inlineCode",{parentName:"li"},"lakos")," library, which can build the diagram and even warn you if you have cycles in the dependencies."),(0,o.kt)("li",{parentName:"ul"},"And again, think! It won't be clean architecture ",(0,o.kt)("strong",{parentName:"li"},"versus")," pragmatic architecture. You can have clean ",(0,o.kt)("strong",{parentName:"li"},"and")," pragmatic architecture.")),(0,o.kt)("p",null,"Of course, this is a very big topic, and a lot can be discussed here, so if you're interested, feel free to check out the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/ookami-kb/my_tmdb"},"repository"),", create issues, raise questions, and let's have a discussion."))}d.isMDXComponent=!0},6478:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/CleanArchitecture-26ac5f08c770e19c35a8ef38b905373f.jpg"},9108:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/dag-40688190740a7c2dad99a4fe319cae32.png"},9167:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/structure1-dc21af7523c7356d5d00ab09d326a974.png"},8088:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/structure2-8011ac233ce476bf79a966e8a46e0655.png"},3802:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/structure3-f2e4e6bea7b67e8d67b17e12f8718990.png"}}]);