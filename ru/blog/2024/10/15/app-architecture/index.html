<!doctype html>
<html lang="ru" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.3.1">
<title data-rh="true">App Architecture: Faster, Better… Simpler | ookamikb.dev</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://ookamikb.dev/ru/blog/2024/10/15/app-architecture/"><meta data-rh="true" name="docusaurus_locale" content="ru"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="ru"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="App Architecture: Faster, Better… Simpler | ookamikb.dev"><meta data-rh="true" name="description" content="As a Staff Mobile Engineer at Mews, I’ve come to realize the title “Staff Engineer” is quite vague, with responsibilities varying from company to company and even between departments. In my role, I don’t belong to any specific team; instead, I assist other engineers and teams with code reviews, architectural decisions, and ad-hoc issues. I also consult for other companies and startups, reviewing their code and mentoring their teams. This exposure to different approaches in app architecture has given me insights into what works and what doesn’t. Today, I’d like to discuss how to make your architecture simpler, more reliable, and more manageable."><meta data-rh="true" property="og:description" content="As a Staff Mobile Engineer at Mews, I’ve come to realize the title “Staff Engineer” is quite vague, with responsibilities varying from company to company and even between departments. In my role, I don’t belong to any specific team; instead, I assist other engineers and teams with code reviews, architectural decisions, and ad-hoc issues. I also consult for other companies and startups, reviewing their code and mentoring their teams. This exposure to different approaches in app architecture has given me insights into what works and what doesn’t. Today, I’d like to discuss how to make your architecture simpler, more reliable, and more manageable."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2024-10-15T00:00:00.000Z"><link data-rh="true" rel="icon" href="/ru/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://ookamikb.dev/ru/blog/2024/10/15/app-architecture/"><link data-rh="true" rel="alternate" href="https://ookamikb.dev/blog/2024/10/15/app-architecture/" hreflang="en"><link data-rh="true" rel="alternate" href="https://ookamikb.dev/ru/blog/2024/10/15/app-architecture/" hreflang="ru"><link data-rh="true" rel="alternate" href="https://ookamikb.dev/blog/2024/10/15/app-architecture/" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/ru/blog/rss.xml" title="ookamikb.dev RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/ru/blog/atom.xml" title="ookamikb.dev Atom Feed">
<link rel="alternate" type="application/json" href="/ru/blog/feed.json" title="ookamikb.dev JSON Feed">




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/ru/assets/css/styles.27a48f3b.css">
<link rel="preload" href="/ru/assets/js/runtime~main.d9670645.js" as="script">
<link rel="preload" href="/ru/assets/js/main.960fd028.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="Перейти к основному содержимому"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">Перейти к основному содержимому</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Переключить навигационную панель" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/ru/"><div class="navbar__logo"><img src="/ru/img/logo.svg" alt="ookamikb.dev Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/ru/img/logo.svg" alt="ookamikb.dev Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">ookamikb.dev</b></a><a class="navbar__item navbar__link" href="/ru/docs/intro/">Docs</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/ru/blog/">Blog</a><a class="navbar__item navbar__link" href="/ru/talks/">Talks</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link"><svg viewBox="0 0 24 24" width="20" height="20" aria-hidden="true" class="iconLanguage_nlXk"><path fill="currentColor" d="M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z"></path></svg>Русский</a><ul class="dropdown__menu"><li><a href="/blog/2024/10/15/app-architecture/" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">English</a></li><li><a href="/ru/blog/2024/10/15/app-architecture/" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="ru">Русский</a></li></ul></div><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Переключение между темным и светлым режимом (сейчас используется Светлый режим)" aria-label="Переключение между темным и светлым режимом (сейчас используется Светлый режим)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="Навигация по последним постам в блоге"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/ru/blog/2024/10/15/app-architecture/">App Architecture: Faster, Better… Simpler</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ru/blog/2023/11/21/dcm/">DCM: When the Built-In Analyzer Isn&#x27;t Enough</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ru/blog/2023/02/14/clean-architecture-vs-pragmatic-architecture/">&quot;Clean&quot; Architecture vs pragmatic architecture</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ru/blog/2022/09/02/flutter-nfc/">Working with NFC in Flutter</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/ru/blog/2021/12/19/viewmodel-ru/">ViewModel во Flutter – это антипаттерн</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">App Architecture: Faster, Better… Simpler</h1><div class="container_mt6G margin-vert--md"><time datetime="2024-10-15T00:00:00.000Z" itemprop="datePublished">15 октября 2024 г.</time> · <!-- -->15 мин. чтения</div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>As a Staff Mobile Engineer at Mews, I’ve come to realize the title “Staff Engineer” is quite vague, with responsibilities varying from company to company and even between departments. In my role, I don’t belong to any specific team; instead, I assist other engineers and teams with code reviews, architectural decisions, and ad-hoc issues. I also consult for other companies and startups, reviewing their code and mentoring their teams. This exposure to different approaches in app architecture has given me insights into what works and what doesn’t. Today, I’d like to discuss how to make your architecture simpler, more reliable, and more manageable.</p><p>This is the text version of my <a href="https://fluttercon.dev/" target="_blank" rel="noopener noreferrer">talk at Fluttercon Berlin 2024</a>. You can find the video <a href="https://www.droidcon.com/2024/09/03/app-architecture-faster-better-simpler/" target="_blank" rel="noopener noreferrer">here</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="what-is-and-isnt-app-architecture">What is (and isn’t) app architecture<a href="#what-is-and-isnt-app-architecture" class="hash-link" aria-label="Прямая ссылка на What is (and isn’t) app architecture" title="Прямая ссылка на What is (and isn’t) app architecture">​</a></h2><p>Before we define what app architecture is, let’s clarify what it’s not. When I’m introduced to a new app and ask the team to describe their current architecture, I often hear responses like:</p><ul><li>“It’s BLoC.”</li><li>“We use Riverpod.”</li><li>“It’s an MVVM architecture.”</li></ul><p>The issue is that these are not descriptions of an app’s architecture. BLoC and Riverpod are state management tools, and MVVM is an architectural pattern for the presentation layer. While important, they don’t define your app’s overall architecture.</p><p>Sometimes, the response is, “We have a SOLID-based architecture.” Again, this doesn’t tell me much. SOLID is a set of principles that can be useful (though not always, as we’ll discuss later), but it’s not a representation of your app’s architecture.</p><p>Another popular answer is, “We use Clean Architecture.” You might think this is spot-on—it even has “architecture” in the name. However, there are several problems with this:</p><ol><li><strong>Lack of specificity:</strong> Even if applied correctly, Clean Architecture doesn’t say much about your specific app. It’s a set of principles to build your app’s architecture, resulting in countless possible architectures.</li><li><strong>Misapplication:</strong> I often see implementations of Clean Architecture that don’t follow its core principles.</li><li><strong>Unsuitability for Flutter apps:</strong> The strict approach to Clean Architecture doesn’t work well with Flutter apps. I discussed this in detail in my article <a href="https://ookamikb.dev/blog/2023/02/14/clean-architecture-vs-pragmatic-architecture/" target="_blank" rel="noopener noreferrer">Clean Architecture vs. Pragmatic Architecture</a>. In short, Clean Architecture speaks to entire software systems where a mobile app is just a part. It focuses too much on separate deployments and is overly defensive about business logic—which most mobile apps lack.</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-goal-of-software-architecture">The goal of software architecture<a href="#the-goal-of-software-architecture" class="hash-link" aria-label="Прямая ссылка на The goal of software architecture" title="Прямая ссылка на The goal of software architecture">​</a></h2><p>Before defining app architecture, let’s discuss its goal. I appreciate Robert Martin’s definition from his book Clean Architecture:</p><p>“The goal of software architecture is to minimize the human resources required to build and maintain the required system.”</p><p>The key word here is <strong>“maintain“</strong>. We seldom create apps that aren’t intended for future maintenance. Maintenance—which includes fixing bugs and adding new features—is the most significant part of an app’s lifecycle. Therefore, making this phase as straightforward as possible is crucial.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="defining-app-architecture">Defining app architecture<a href="#defining-app-architecture" class="hash-link" aria-label="Прямая ссылка на Defining app architecture" title="Прямая ссылка на Defining app architecture">​</a></h2><p>So, what is app architecture? According to Wikipedia:</p><blockquote><p>“Software architecture is the set of structures needed to reason about a software system and the discipline of creating such structures and systems. Each structure comprises software elements, relations among them, and properties of both elements and relations.”</p></blockquote><p>Many tutorials focus on components and their properties but often overlook the crucial aspect of relationships between components.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="understanding-components-in-your-app">Understanding components in your app<a href="#understanding-components-in-your-app" class="hash-link" aria-label="Прямая ссылка на Understanding components in your app" title="Прямая ссылка на Understanding components in your app">​</a></h2><p>Let’s delve into components, which I’ll use interchangeably with features and modules. Simon Brown defines a component as:</p><p>“A grouping of related functionality behind a nice clean interface, which resides inside an execution environment like an application.”</p><p>In the context of app components:</p><ul><li>They are not screens, although a screen can be part of a component.</li><li>They are not necessarily user flows. While something like a “User Registration Flow” can be a component, components shouldn’t be divided exclusively by user flows.</li><li>They are not just global responsibilities. For example, “auth” doesn’t have to be a separate component encompassing all authentication-related elements.</li></ul><p>Instead, think of components from the loose coupling, high cohesion perspective:</p><ul><li><strong>High cohesion:</strong> Everything inside the module should have closely related functionality.</li><li><strong>Loose coupling:</strong> Connections to the outside should be minimal.</li><li><strong>Encapsulation:</strong> Other components shouldn’t concern themselves with a module’s implementation details; they should treat it as a black box.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="an-example-component-structure">An example component structure<a href="#an-example-component-structure" class="hash-link" aria-label="Прямая ссылка на An example component structure" title="Прямая ссылка на An example component structure">​</a></h2><p>What can be inside a component? As long as you adhere to encapsulation and loose coupling/high cohesion, the specifics are flexible. Here’s a structure I often use:</p><p><img loading="lazy" alt="img.png" src="/ru/assets/images/img-c4824d7c03be58c57b4ce6a5aebb559f.png" width="1600" height="744" class="img_ev3q"></p><ol><li><strong>Screens:</strong> The top-level layer and the first candidate to be used by other components. If you can use a whole screen from another module, that’s excellent—you don’t need to care about its implementation.</li><li><strong>Widgets:</strong> Screens consist of widgets. Contrary to some practices, widgets aren’t just dumb view components (more on this shortly).</li><li><strong>Services layer:</strong> Some call this the Business Logic layer, but I prefer not to, as most apps lack true business logic. Instead, this layer handles application logic—abstracted from the UI but specific to the app. State management patterns like BLoC typically belong here.</li><li><strong>Data layer:</strong> This includes implementations of repositories and API clients. Keep them as simple as possible; you usually mock these in tests, so you don’t want complex logic here.</li><li><strong>Models layer:</strong> Only models shared between different parts of the module or between different modules go here (though I usually discourage cross-module sharing). If a model is only used by a repository or service, place it close to the corresponding class in the same file. These aren’t rich domain models; they’re typically just data holders.</li></ol><h2 class="anchor anchorWithStickyNavbar_LWe7" id="widgets-are-not-just-dumb-views">Widgets are not just dumb views<a href="#widgets-are-not-just-dumb-views" class="hash-link" aria-label="Прямая ссылка на Widgets are not just dumb views" title="Прямая ссылка на Widgets are not just dumb views">​</a></h2><p>Some developers split widgets into ModelViews and Views, but I advise against this. I find MVVM in Flutter to be an anti-pattern, as I discussed in <a href="https://www.youtube.com/watch?v=J7fDHul6Oao" target="_blank" rel="noopener noreferrer">this video</a>.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="do-we-need-all-these-layers">Do we need all these layers?<a href="#do-we-need-all-these-layers" class="hash-link" aria-label="Прямая ссылка на Do we need all these layers?" title="Прямая ссылка на Do we need all these layers?">​</a></h2><p>Definitely not. Avoid adding abstractions if they don’t encapsulate any logic. If your service merely proxies calls to the repository, you don’t need it. Let the widget directly call the repository. Layers can communicate with any lower layers, not just their immediate child layer. In practice, you’ll often have just a couple of layers: widgets and services or widgets and data. However, dependency direction should always be one-way.</p><p>You can set up the DCM static analyzer to enforce this direction, preventing, for example, importing a file from the data folder into a file in the widgets folder.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="about-dependency-inversion">About dependency inversion<a href="#about-dependency-inversion" class="hash-link" aria-label="Прямая ссылка на About dependency inversion" title="Прямая ссылка на About dependency inversion">​</a></h2><p>You might notice that there’s no dependency inversion in this structure—the services layer calls the data layer directly. This might seem terrible, but let’s discuss why we need this principle: it allows us to depend on interfaces, not implementations. In Dart, every class defines an implicit interface. With implicit interfaces, you can have another implementation of the class for testing without needing additional abstractions that can complicate thinking.</p><p>This doesn’t mean you should never create separate interfaces. They can be useful, especially when combined with the Interface Segregation Principle. However, avoid creating a separate class with only one implementation in the main code, particularly when that implementation is just the interface name with an Impl suffix.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="where-does-bloc-belong">Where does BLoC belong?<a href="#where-does-bloc-belong" class="hash-link" aria-label="Прямая ссылка на Where does BLoC belong?" title="Прямая ссылка на Where does BLoC belong?">​</a></h2><p>Does BLoC always belong to the services layer? It depends. BLoC, as a library, is an implementation of the Finite State Machine pattern. If you use it to handle application logic and state, it sits in the services folder. If it’s managing a complex UI state, it’s part of the widgets layer. Asking whether BLoC is UI or services is like asking whether a Singleton is part of the data layer or if a Factory should only be used in views.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="re-examining-solid-principles">Re-examining SOLID principles<a href="#re-examining-solid-principles" class="hash-link" aria-label="Прямая ссылка на Re-examining SOLID principles" title="Прямая ссылка на Re-examining SOLID principles">​</a></h2><p>Since we’ve touched on the Dependency Inversion Principle, let’s discuss the other SOLID principles.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="single-responsibility-principle-srp">Single Responsibility Principle (SRP)<a href="#single-responsibility-principle-srp" class="hash-link" aria-label="Прямая ссылка на Single Responsibility Principle (SRP)" title="Прямая ссылка на Single Responsibility Principle (SRP)">​</a></h3><p>This is perhaps the most misinterpreted principle, partly due to its confusing name. Many believe it’s about a class or function doing only one thing. In Clean Architecture, Robert Martin clarifies that SRP is about one reason to change, meaning responsibility to one actor. It’s more about grouping related functionality together, aligning with the loose coupling and high cohesion principle. In this sense, it’s invaluable for structuring your app’s modules.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="openclosed-principle-ocp">Open/Closed Principle (OCP)<a href="#openclosed-principle-ocp" class="hash-link" aria-label="Прямая ссылка на Open/Closed Principle (OCP)" title="Прямая ссылка на Open/Closed Principle (OCP)">​</a></h3><p>This principle states that software entities should be open for extension but closed for modification. On a module level, it suggests having a stable and extensible API. However, not all components need to be stable—some change frequently due to product requirements or dependencies.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="liskov-substitution-principle-lsp">Liskov Substitution Principle (LSP)<a href="#liskov-substitution-principle-lsp" class="hash-link" aria-label="Прямая ссылка на Liskov Substitution Principle (LSP)" title="Прямая ссылка на Liskov Substitution Principle (LSP)">​</a></h3><p>LSP is crucial when dealing with class hierarchies, but inheritance can be complex and fragile. In general, it’s often better to avoid deep inheritance structures.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="interface-segregation-principle-isp">Interface Segregation Principle (ISP)<a href="#interface-segregation-principle-isp" class="hash-link" aria-label="Прямая ссылка на Interface Segregation Principle (ISP)" title="Прямая ссылка на Interface Segregation Principle (ISP)">​</a></h3><p>This is the one principle where I have few reservations. It’s beneficial because if your code doesn’t depend on methods it doesn’t use, the system becomes easier to understand, test, and maintain. However, it can lead to more boilerplate code. For example, any class with more than one client and more than one method (like a Repository or ApiClient) might violate this principle. Again, be reasonable in its application.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dependency-inversion-principle-dip">Dependency Inversion Principle (DIP)<a href="#dependency-inversion-principle-dip" class="hash-link" aria-label="Прямая ссылка на Dependency Inversion Principle (DIP)" title="Прямая ссылка на Dependency Inversion Principle (DIP)">​</a></h3><p>As previously discussed, I advise against applying DIP rigidly within component layers. It can be highly useful when dealing with the stability and flexibility of components, but it shouldn’t be applied everywhere just because it’s possible.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="general-thoughts-on-solid">General thoughts on SOLID<a href="#general-thoughts-on-solid" class="hash-link" aria-label="Прямая ссылка на General thoughts on SOLID" title="Прямая ссылка на General thoughts on SOLID">​</a></h3><p>SOLID principles are somewhat vague initially. Authors, including Robert Martin, present them as universal, promoting their use at class, module, and architecture levels. While they often make sense, they can sometimes feel artificial. I suggest being skeptical—know the principles but avoid following them blindly. They are not laws. You can build bad software that follows these principles and good software that violates them (in some places, not everywhere).</p><p>Violating any of these principles isn’t inherently good or bad—it’s about why you violate them or apply them. If you can justify your decisions, adherence to the principles becomes less critical.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="the-misunderstood-dry-principle">The misunderstood DRY principle<a href="#the-misunderstood-dry-principle" class="hash-link" aria-label="Прямая ссылка на The misunderstood DRY principle" title="Прямая ссылка на The misunderstood DRY principle">​</a></h2><p>I chose to discuss SOLID and DRY because they frequently appear in job postings, almost becoming an idée fixe.</p><p>The DRY (Don’t Repeat Yourself) principle, along with SRP, is one of the most misinterpreted. The confusion often arises from its name. It’s not about code repetition per se; it’s about maintaining a single source of truth for your logic.</p><p>People often describe WET (Write Everything Twice) as the opposite of DRY, which highlights the misunderstanding. The number of repetitions isn’t the issue; it’s the repetition of logic or knowledge that should be avoided. If you’re repeatedly creating a widget with the same parameters, you don’t necessarily need to introduce a new wrapping widget.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="focusing-on-component-relations">Focusing on component relations<a href="#focusing-on-component-relations" class="hash-link" aria-label="Прямая ссылка на Focusing on component relations" title="Прямая ссылка на Focusing on component relations">​</a></h2><p>Now that we’ve discussed components and their internal relationships, let’s switch to a more intriguing and less discussed topic: relations between components.</p><p>When I ask about your app architecture, this is usually what I want to hear—how your components interact. This is the main characteristic that determines whether your app is a “big ball of mud” or a well-structured, maintainable piece of software. It also allows someone to understand what your app does without delving into the code.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="understanding-through-component-graphs">Understanding through component graphs<a href="#understanding-through-component-graphs" class="hash-link" aria-label="Прямая ссылка на Understanding through component graphs" title="Прямая ссылка на Understanding through component graphs">​</a></h2><p>Consider these two images:</p><p><img loading="lazy" alt="img_1.png" src="/ru/assets/images/img_1-223ccc95c3c80316f363c06947164e4d.png" width="1600" height="625" class="img_ev3q"></p><p>The left one describes a general architecture or principles that can be used to create an app architecture—it doesn’t tell me anything specific about your app. The right one depicts the architecture of a specific app. It’s much more informative when we want to understand what your app is about and how it’s built.</p><p>By examining the components graph, we can deduce that the app involves movies, favorites, search, and profiles—it appears to be a movie search app that allows users to create a list of favorite movies.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="assessing-component-dependencies">Assessing component dependencies<a href="#assessing-component-dependencies" class="hash-link" aria-label="Прямая ссылка на Assessing component dependencies" title="Прямая ссылка на Assessing component dependencies">​</a></h2><p>Looking at the “content” module, we see it doesn’t depend on any other component:</p><p><img loading="lazy" alt="img_2.png" src="/ru/assets/images/img_2-70059397726c13681853254e65786946.png" width="1600" height="747" class="img_ev3q"></p><p>This means ease of testing: Since it doesn’t depend on anything else, we can test it in isolation, regardless of the state of the rest of the app.</p><p>At the same time, many other components depend on it, so changes here can cascade through the app:</p><p><img loading="lazy" alt="img_3.png" src="/ru/assets/images/img_3-223ccc95c3c80316f363c06947164e4d.png" width="1600" height="625" class="img_ev3q"></p><p>This makes it a “stable” component—you don’t want its API to change frequently.</p><p>Conversely, the “dashboard” component has no other components depending on it:</p><p><img loading="lazy" alt="img_4.png" src="/ru/assets/images/img_4-1b5d9b87dcb2738c8d6de6c33b3e0a33.png" width="1600" height="535" class="img_ev3q"></p><p>Such a component is considered “irresponsible.” It’s safe to change because you won’t break other components, making it very unstable.</p><p>However, since it depends on every other component (directly or transitively), testing it could be challenging without proper abstractions:</p><p><img loading="lazy" alt="img_5.png" src="/ru/assets/images/img_5-cb88cb063d5b3999d858ce8ea24c225e.png" width="1600" height="663" class="img_ev3q"></p><p>Most likely, this component serves as an entry point to the rest of the app, making it a good candidate for end-to-end or integration tests.</p><p>Without even looking at the code, we’ve gained insights into:</p><ul><li>The app’s functionality.</li><li>Which parts are easier to test.</li><li>Which components might be hard to change.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="avoiding-cycles-in-dependencies">Avoiding cycles in dependencies<a href="#avoiding-cycles-in-dependencies" class="hash-link" aria-label="Прямая ссылка на Avoiding cycles in dependencies" title="Прямая ссылка на Avoiding cycles in dependencies">​</a></h2><p><img loading="lazy" alt="img_6.png" src="/ru/assets/images/img_6-1b5d9b87dcb2738c8d6de6c33b3e0a33.png" width="1600" height="535" class="img_ev3q"></p><p>One crucial aspect to monitor is the absence of cycles in your dependencies—your dependencies should form a Directed Acyclic Graph (DAG). Cycles turn modules within the cycle into one big module. For example, if the “profile” module depends on “auth,” “auth” depends on “dashboard,” and “dashboard” depends back on “profile,” you effectively have one large module. You can’t use or test these modules separately, and changes in one will likely necessitate changes in the others.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="ensuring-loose-coupling-and-high-cohesion">Ensuring loose coupling and high cohesion<a href="#ensuring-loose-coupling-and-high-cohesion" class="hash-link" aria-label="Прямая ссылка на Ensuring loose coupling and high cohesion" title="Прямая ссылка на Ensuring loose coupling and high cohesion">​</a></h2><p><img loading="lazy" alt="img_7.png" src="/ru/assets/images/img_7-cb88cb063d5b3999d858ce8ea24c225e.png" width="1600" height="663" class="img_ev3q"></p><p>Check for loose coupling and high cohesion within your modules. If you notice few internal connections but many external ones, you might be violating this principle. To fix this, consider rearranging files within modules. Remember, modules aren’t necessarily grouped by use case or screens—they’re about keeping highly cohesive functionality together.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="tools-for-analyzing-component-relations">Tools for analyzing component relations<a href="#tools-for-analyzing-component-relations" class="hash-link" aria-label="Прямая ссылка на Tools for analyzing component relations" title="Прямая ссылка на Tools for analyzing component relations">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="using-lakos-for-dependency-graphs">Using Lakos for dependency graphs<a href="#using-lakos-for-dependency-graphs" class="hash-link" aria-label="Прямая ссылка на Using Lakos for dependency graphs" title="Прямая ссылка на Using Lakos for dependency graphs">​</a></h3><p>For a total graph of all file relationships, I use the Lakos library. Even for a small project, the graph can look intimidating:</p><p><img loading="lazy" alt="img_8.png" src="/ru/assets/images/img_8-223ccc95c3c80316f363c06947164e4d.png" width="1600" height="625" class="img_ev3q"></p><p>The good news is you don’t need to check it manually; Lakos can report if there are cycles in the graph.</p><p>In most cases, you’re only interested in the outcome: isAcyclic: true. You can set up Lakos to return an error if cycles are detected, integrating it into your CI/CD pipeline. It works quickly because it doesn’t perform static analysis of Dart code —it simply parses import statements.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="dart-code-metrics-for-component-analysis">Dart code metrics for component analysis<a href="#dart-code-metrics-for-component-analysis" class="hash-link" aria-label="Прямая ссылка на Dart code metrics for component analysis" title="Прямая ссылка на Dart code metrics for component analysis">​</a></h3><p><img loading="lazy" alt="img_9.png" src="/ru/assets/images/img_9-223ccc95c3c80316f363c06947164e4d.png" width="1600" height="625" class="img_ev3q"></p><p>For more complex tasks like grouping files into modules, the Dart Code Metrics tool with its new analyze-structure command is helpful. Note that this command is in an early preview, so some functionality might be missing or subject to change.</p><p>This tool allows you to build a components graph, grouping dependencies within components:</p><p><img loading="lazy" alt="img_10.png" src="/ru/assets/images/img_10-434eebec70fcf5ef290091e9aa0e8244.png" width="1600" height="747" class="img_ev3q"></p><p>While it doesn’t automatically check for cycles yet, the components graph is simpler, making manual checks feasible.</p><p>You can also run a script on the Graphviz file it produces to detect cycles.</p><p>Remember, it’s important to check for cycles in both the full graph and the components graph, as one might be acyclic while the other isn’t.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="benefits-of-this-approach">Benefits of this approach<a href="#benefits-of-this-approach" class="hash-link" aria-label="Прямая ссылка на Benefits of this approach" title="Прямая ссылка на Benefits of this approach">​</a></h2><h3 class="anchor anchorWithStickyNavbar_LWe7" id="flexibility">Flexibility<a href="#flexibility" class="hash-link" aria-label="Прямая ссылка на Flexibility" title="Прямая ссылка на Flexibility">​</a></h3><p>With more or less independent modules, it’s easier to split work among developers and make independent changes.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="transparency">Transparency<a href="#transparency" class="hash-link" aria-label="Прямая ссылка на Transparency" title="Прямая ссылка на Transparency">​</a></h3><p>Having an overview of stable and unstable components allows you to plan refactorings and understand which components are easier to test and which are risky to change.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="maintainability">Maintainability<a href="#maintainability" class="hash-link" aria-label="Прямая ссылка на Maintainability" title="Прямая ссылка на Maintainability">​</a></h3><p>As the second law of thermodynamics suggests, entropy (or chaos) in any isolated system tends to increase over time. Without constant maintenance, disorder grows. However, with this approach, chaos can be localized—no matter how messy one module gets, it shouldn’t significantly affect others.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="simplicity">Simplicity<a href="#simplicity" class="hash-link" aria-label="Прямая ссылка на Simplicity" title="Прямая ссылка на Simplicity">​</a></h3><p>Avoid unnecessary abstractions. Don’t focus on multiple layers just for the sake of it. Keep things simple and concentrate on the relationships between your modules. A litmus test to check if an abstraction is needed: ask yourself why you added it. If your answer starts with “If in the future…,” stop—you probably don’t need it. Saying “it’s cleaner” isn’t a sufficient reason.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="scalability">Scalability<a href="#scalability" class="hash-link" aria-label="Прямая ссылка на Scalability" title="Прямая ссылка на Scalability">​</a></h3><p>With a decomposed system, you can strategically target weak points and evolve the system. If your system grows further, you can easily switch to a modular architecture—groups of components can be extracted as separate modules.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="is-this-clean-architecture">Is this Clean Architecture?<a href="#is-this-clean-architecture" class="hash-link" aria-label="Прямая ссылка на Is this Clean Architecture?" title="Прямая ссылка на Is this Clean Architecture?">​</a></h2><p>When rehearsing my presentation, someone commented that this approach resembles Clean Architecture. So, is it an alternative or just a rebranded idea?</p><p>Well, both yes and no. Throughout this discussion, I’ve referred to “Clean Architecture” as it’s commonly implemented in tutorials and real-life projects, where developers take sample implementations from original articles and directly apply them to Flutter apps. I advocate for implementing the ideas of Clean Architecture—clear boundaries, well-defined dependencies, and module isolation—while remaining skeptical and pragmatic. In that sense, this approach is closer to the original intent of Clean Architecture than blindly replicating UseCase, Presenter, Repository, and Datasource classes across projects.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="key-differences">Key differences<a href="#key-differences" class="hash-link" aria-label="Прямая ссылка на Key differences" title="Прямая ссылка на Key differences">​</a></h2><ul><li><strong>Simplification:</strong> Streamlining the architecture to focus on what’s essential.</li><li><strong>Inversion of dependency inversion:</strong> Sometimes, just having direct dependencies is more practical.</li><li><strong>Component structuring:</strong> Organizing by components defined through cohesion.</li><li><strong>Small components:</strong> Keeping components as small and manageable as possible.</li><li><strong>Focus on relationships:</strong> Concentrating on how components interact rather than adhering strictly to predefined layers.</li></ul><h2 class="anchor anchorWithStickyNavbar_LWe7" id="conclusion">Conclusion<a href="#conclusion" class="hash-link" aria-label="Прямая ссылка на Conclusion" title="Прямая ссылка на Conclusion">​</a></h2><p>Simplifying your app architecture doesn’t mean sacrificing robustness or scalability. By focusing on component relationships, embracing pragmatism over dogmatism, and utilizing tools to monitor dependencies, you can create an architecture that’s both manageable and adaptable.</p><p>If you have any questions or thoughts, feel free to reach out. Let’s continue the conversation on building better, more maintainable apps.</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Навигация по странице поста блога"><a class="pagination-nav__link pagination-nav__link--next" href="/ru/blog/2023/11/21/dcm/"><div class="pagination-nav__sublabel">Предыдущий пост</div><div class="pagination-nav__label">DCM: When the Built-In Analyzer Isn&#x27;t Enough</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#what-is-and-isnt-app-architecture" class="table-of-contents__link toc-highlight">What is (and isn’t) app architecture</a></li><li><a href="#the-goal-of-software-architecture" class="table-of-contents__link toc-highlight">The goal of software architecture</a></li><li><a href="#defining-app-architecture" class="table-of-contents__link toc-highlight">Defining app architecture</a></li><li><a href="#understanding-components-in-your-app" class="table-of-contents__link toc-highlight">Understanding components in your app</a></li><li><a href="#an-example-component-structure" class="table-of-contents__link toc-highlight">An example component structure</a></li><li><a href="#widgets-are-not-just-dumb-views" class="table-of-contents__link toc-highlight">Widgets are not just dumb views</a></li><li><a href="#do-we-need-all-these-layers" class="table-of-contents__link toc-highlight">Do we need all these layers?</a></li><li><a href="#about-dependency-inversion" class="table-of-contents__link toc-highlight">About dependency inversion</a></li><li><a href="#where-does-bloc-belong" class="table-of-contents__link toc-highlight">Where does BLoC belong?</a></li><li><a href="#re-examining-solid-principles" class="table-of-contents__link toc-highlight">Re-examining SOLID principles</a><ul><li><a href="#single-responsibility-principle-srp" class="table-of-contents__link toc-highlight">Single Responsibility Principle (SRP)</a></li><li><a href="#openclosed-principle-ocp" class="table-of-contents__link toc-highlight">Open/Closed Principle (OCP)</a></li><li><a href="#liskov-substitution-principle-lsp" class="table-of-contents__link toc-highlight">Liskov Substitution Principle (LSP)</a></li><li><a href="#interface-segregation-principle-isp" class="table-of-contents__link toc-highlight">Interface Segregation Principle (ISP)</a></li><li><a href="#dependency-inversion-principle-dip" class="table-of-contents__link toc-highlight">Dependency Inversion Principle (DIP)</a></li><li><a href="#general-thoughts-on-solid" class="table-of-contents__link toc-highlight">General thoughts on SOLID</a></li></ul></li><li><a href="#the-misunderstood-dry-principle" class="table-of-contents__link toc-highlight">The misunderstood DRY principle</a></li><li><a href="#focusing-on-component-relations" class="table-of-contents__link toc-highlight">Focusing on component relations</a></li><li><a href="#understanding-through-component-graphs" class="table-of-contents__link toc-highlight">Understanding through component graphs</a></li><li><a href="#assessing-component-dependencies" class="table-of-contents__link toc-highlight">Assessing component dependencies</a></li><li><a href="#avoiding-cycles-in-dependencies" class="table-of-contents__link toc-highlight">Avoiding cycles in dependencies</a></li><li><a href="#ensuring-loose-coupling-and-high-cohesion" class="table-of-contents__link toc-highlight">Ensuring loose coupling and high cohesion</a></li><li><a href="#tools-for-analyzing-component-relations" class="table-of-contents__link toc-highlight">Tools for analyzing component relations</a><ul><li><a href="#using-lakos-for-dependency-graphs" class="table-of-contents__link toc-highlight">Using Lakos for dependency graphs</a></li><li><a href="#dart-code-metrics-for-component-analysis" class="table-of-contents__link toc-highlight">Dart code metrics for component analysis</a></li></ul></li><li><a href="#benefits-of-this-approach" class="table-of-contents__link toc-highlight">Benefits of this approach</a><ul><li><a href="#flexibility" class="table-of-contents__link toc-highlight">Flexibility</a></li><li><a href="#transparency" class="table-of-contents__link toc-highlight">Transparency</a></li><li><a href="#maintainability" class="table-of-contents__link toc-highlight">Maintainability</a></li><li><a href="#simplicity" class="table-of-contents__link toc-highlight">Simplicity</a></li><li><a href="#scalability" class="table-of-contents__link toc-highlight">Scalability</a></li></ul></li><li><a href="#is-this-clean-architecture" class="table-of-contents__link toc-highlight">Is this Clean Architecture?</a></li><li><a href="#key-differences" class="table-of-contents__link toc-highlight">Key differences</a></li><li><a href="#conclusion" class="table-of-contents__link toc-highlight">Conclusion</a></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Contacts</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://t.me/ookami_kb" target="_blank" rel="noopener noreferrer" class="footer__link-item">Telegram<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://twitter.com/ookami_kb" target="_blank" rel="noopener noreferrer" class="footer__link-item">Twitter<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://github.com/ookami-kb/ookami-kb" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li><li class="footer__item"><a href="https://www.linkedin.com/in/ookamikb/" target="_blank" rel="noopener noreferrer" class="footer__link-item">LinkedIn<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 ookamikb.dev. Built with Docusaurus.</div></div></div></footer></div>
<script src="/ru/assets/js/runtime~main.d9670645.js"></script>
<script src="/ru/assets/js/main.960fd028.js"></script>
</body>
</html>